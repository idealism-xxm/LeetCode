#  链接：https://leetcode.com/problems/find-the-difference/
#  题意：给一个字符串 s ，对 s 中的字符随机重排，
#       然后在随机一个位置加上一个新的字母，从而得到字符串 t ，
#       求 t 中新增的字母？


#  数据限制：
#   0 <= s.length <= 1000
#   t.length == s.length + 1
#   s 和 t 只包含小写字母

#  输入：s = "abcd", t = "abcde"
#  输出："e"
#  解释：'e' 是 t 中新增的字母

#  输入：s = "", t = "y"
#  输出："y"
#  解释：'y' 是 t 中新增的字母


#  思路：异或（位运算）
# 
#       第一反应其实是使用 map 统计 s 每个字母的次数，
#       再减去 t 中每个字母的次数。
#       这样最后次数不为 0 的字母就是新增的字母。
# 
#       由于字母只有 26 个，所以时间复杂度和空间复杂度都是 O(1) ，
#       但常数还是比较大的。
# 
#       然后在题解区看到标题可以用异或的方式，突然就明白了，
#       其实还有隐藏条件没有被挖掘出来。
# 
#       我们把 s 和 t 中拼接在一起，那么题目就转化成了：
#           给定一个字符串，其中一个字母出现奇数次，其余字母出现偶数次，
#           求这个出现奇数次的字母？
# 
#       是不是很熟悉？
#       这就是 LeetCode 136 这道题目。
# 
#       完全是考察异或的特性 a ^ a = 0 ，这样最后只有出现奇数次的字母会留下来
# 
#       （当然本题也可以使用加减法抵消，获得类似的结果，因为数据范围比较小，
#       不过对于 136 这题就只能使用异或了）
# 
# 
#       时间复杂度：O(n)
#       空间复杂度：O(1)


class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # 最终字符的 ASCII 码，初始为 0
        ans = 0
        # 遍历 s 和 t 中的所有字符，
        # 使用 itertools.chain 可以将 s 和 t 串起来遍历
        for ch in itertools.chain(s, t):
            # 更新 ans 为 ans ^ ord(ch) 的异或和，
            # ord(ch) 返回字符 ch 的 ASCII 码
            ans ^= ord(ch)
        # 至此，所有出现偶数次的 ASCII 码的异或和会相互抵消，
        # 所以 ans 现在就是只出现奇数次的 ASCII 码，
        # 使用 chr(ans) 转成字符后返回
        return chr(ans)
