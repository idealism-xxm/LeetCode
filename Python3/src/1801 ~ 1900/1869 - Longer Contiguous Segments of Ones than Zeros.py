# 链接：https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/
# 题意：给定一个 01 串 ，判断最长连续为 1 的子串的长度是否大于最长连续为 0 的子串的长度？

# 数据限制：
#   1 <= s.length <= 100
#   s[i] 是 '0' 或 '1'

# 输入： s = "1101"
# 输出： true
# 解释：
#       "1101" 最长连续为 1 的子串是 "11" ，最长连续为 0 的子串是 "0" ，
#       "11" 的长度大于 "0" 的长度，所以返回 true 。

# 输入： s = "111000"
# 输出： false
# 解释：
#       "111000" 最长连续为 1 的子串是 "111" ，最长连续为 0 的子串是 "000" ，
#       "111" 的长度等于 "000" 的长度，所以返回 false 。

# 输入： s = "110100010"
# 输出： false
# 解释：
#       "110100010" 最长连续为 1 的子串是 "11" ，最长连续为 0 的子串是 "000" ，
#       "11" 的长度小于 "000" 的长度，所以返回 false 。

# 思路： 枚举
#
#       维护两个值 mx_zero 和 mx_one ，
#           分布表示全局最长连续为 0 的子串的长度和全局最长连续为 1 的子串的长度
#       维护两个值 cur_zero 和 cur_one ，
#           分布表示以当前字符为结尾的子串，最长连续为 0 的子串的长度和最长连续为 1 的子串的长度
#
#       枚举 s 中的每一个字符 ch ，
#       如果 ch 是 '0' ，则将 cur_zero += 1 ，cur_one = 0 ，并更新 mx_zero ，
#       如果 ch 是 '1' ，则将 cur_zero = 0 ，cur_one += 1 ，并更新 mx_one 。
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)

class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        # 全局最长连续为 0 的子串的长度和全局最长连续为 1 的子串的长度
        mx = [0, 0]
        # 以当前字符为结尾的子串，最长连续为 0 的子串的长度和最长连续为 1 的子串的长度
        # 其中一个必定为 0
        cur = [0, 0]
        for ch in s:
            # 转换成数字
            num = int(ch)
            # 该数字对应的子串长度需要 +1
            cur[num] += 1
            # 另一个数字对应的子串长度需要置 0
            cur[1 - num] = 0
            
            # 更新该数字对应的子串最大长度
            mx[num] = max(mx[num], cur[num])
        
        # 最后判断最长连续为 1 的子串的长度是否大于最长连续为 0 的子串的长度
        return mx[1] > mx[0]
