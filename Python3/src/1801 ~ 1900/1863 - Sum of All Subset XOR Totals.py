# 链接：https://leetcode.com/problems/sum-of-all-subset-xor-totals/
# 题意：给定一个整数数组 nums ，求其所有 2 ^ (len(nums)) 子数组的异或和的和？

# 数据限制：
#   1 <= nums.length <= 12
#   1 <= nums[i] <= 20

# 输入： nums = [1,3]
# 输出： 6
# 解释：
#   [1,3] 的四个子数组为：
#       - 空数组的异或和为 0
#       - [1] 的异或和为 1
#       - [3] 的异或和为 3
#       - [1,3] 的异或和为 1 XOR 3 = 2
#   0 + 1 + 3 + 2 = 6


# 输入： nums = [5,1,6]
# 输出： 28
# 解释：
#   [5,1,6] 的八个子数组为：
#       - 空数组的异或和为 0
#       - [5] 的异或和为 5
#       - [1] 的异或和为 1
#       - [6] 的异或和为 6
#       - [5,1] 的异或和为 5 XOR 1 = 4
#       - [5,6] 的异或和为 5 XOR 6 = 3
#       - [1,6] 的异或和为 1 XOR 6 = 7
#       - [5,1,6] 的异或和为 5 XOR 1 XOR 6 = 2
#   0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

# 输入： nums = [3,4,5,6,7,8]
# 输出： 480

# 思路： 异或
#
#       如果所有数的第 i 位都是 0 ，那么所有自数组的异或和的第 i 位也都是 0 。
#       假设全部 n 个数中有 k 个数第 i 位是 1 ，其余 n - k 个数第 i 位是 0 ，
#       那么最后的子数组中能让第 i 位为 1 就必须从 k 个数中选择奇数个数，
#           对应的方案数为： C(k, 1) + C(k, 3) + ... = 2 ^ (k - 1) 
#       剩余的 n - k 的数如何选取都不会影响结果，
#           对应的方案数为： C(n - k, 0) + C(n - k, 1) + ... + C(n - k, n - k) = 2 ^ (n - k)
#       那么所有子数组中第 i 位为 1 的方案数为： 
#           (2 ^ (k - 1)) * (2 ^ (n - k)) = 2 ^ (k - 1 + n - k) = 2 ^ (n - 1)
#
#       可以发现最终结果与 k 无关，也就是只要有一个数第 i 位为 1 ，
#       那么最终子数组的异或和第 i 位为 1 的情况出现了 2 ^ (n - 1) ，
#       那么其对最终和的贡献为 (2 ^ i) * 2 ^ (n - 1)
#
#       综上，最终和为 sum(2 ^ i) * 2 ^ (n - 1) ，其中 i 满足至少一个数第 i 位为 1 
#       简化后可得： OR(nums) * 2 ^ (n - 1) ，其中 OR(nums) 表示 nums 中所有书的按位或
#
#       【证明】 C(k, 1) + C(k, 3) + ... = 2 ^ (k - 1)
#        1. 2 ^ k = (1 + 1) ^ k
#                 = sigema(i = 0, k, C(k, i))
#                   # 按照奇偶分组，偶数系数为正，奇数系数为正
#                 = sigema(i = 0|2|4|..., k, C(k, i)) + sigema(i = 1|3|5|..., k, C(k, i)) 
#        2. 0 = (1 - 1) ^ k
#             = sigema(i = 0, k, C(k, i) * (-1) ^ i)
#               # 按照奇偶分组，偶数系数为正，奇数系数为负
#             = sigema(i = 0|2|4|..., k, C(k, i)) - sigema(i = 1|3|5|..., k, C(k, i)) 
#             = (C(k, 0) + C(k, 2) + C(k, 4) + ...) - (C(k, 1) + C(k, 3) + C(k, 5) + ...)
#           -> C(k, 0) + C(k, 2) + C(k, 4) + ... = C(k, 1) + C(k, 3) + C(k, 5) + ...
#
#       由 1, 2 可得 C(k, 0) + C(k, 2) + C(k, 4) + ... = C(k, 1) + C(k, 3) + C(k, 5) + ... = 2 ^ (k - 1)
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)


class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        # 由于每一位只要有一个数位 1 ，就会对结果产生贡献，
        # 所以我们将所有数按位或起来
        bits = 0
        for num in nums:
            bits |= num

        # 每一个数第 i 位为 1 的位都会对和产生 (1 << (len(nums) - 1)) 次贡献
        return bits * (1 << (len(nums) - 1))
