# 链接：https://leetcode.com/problems/stone-game-viii/
# 题意：给定长度为 n 的整数数组 stones ， stones[i] 表示第 i 块石头的值，
#       现在两个人轮流玩一个游戏，只要剩余的石头数大于 1 ，每个人可以做如下操作：
#           选取左边任意连续 x (x > 1) 块石头，这些石头的值之和为 total ，
#           这个人可以把这个值加到自己的总分中，
#           然后在剩余石头的左侧放下一块值为 total 的石头。
#       游戏得分为：先手总分 - 后手总分，
#       先手目标是让游戏得分最大，后手目标是让游戏得分最小，
#       两个人都按照最优策略进行游戏，求最后游戏得分是多少？

# 数据限制：
#   n == stones.length
#   2 <= n <= 10 ^ 5
#   -10 ^ 4 <= stones[i] <= 10 ^ 4

# 输入： stones = [-1,2,-3,4,-5]
# 输出： 5
# 解释：
#   - 先手拿前 4 块石头，总和为 (-1) + 2 + (-3) + 4 = 2 ，然后放下一块值为 2 的石头，
#     现在：先手总分 = 2 ，后手总分 = 0 ，剩余石头为 [2,-5]
#   - 后手拿前 2 块石头，总和为 2 + (-5) = -3 ，然后放下一块值为 -3 的石头，
#     现在：先手总分 = 2 ，后手总分 = -3 ，剩余石头为 [-3]
#   两者分差为 2 - (-3) = 5


# 输入： stones = [7,-6,5,10,5,-2,-6]
# 输出： false
# 解释：
#   - 先手拿全部石头，总和为 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，然后放下一块值为 13 的石头，
#     现在：先手总分 = 13 ，后手总分 = 0 ，剩余石头为 [13]
#   两者分差为 13 - 0 = 13

# 输入： stones = [-10,-12]
# 输出： -22
# 解释：
#   - 先手只能拿全部石头，总和为 -10 + (-12) = -22 ，然后放下一块值为 -22 的石头，
#     现在：先手总分 = -22 ，后手总分 = 0 ，剩余石头为 [-22]
#   两者分差为 -22 - 0 = -22

# 思路： DP
#
#       设 prefix[i] 表示前 i 块石头的和，
#       设 dp[i] 表示游戏从第 i 块石头开始时先手能获得的最大游戏得分，
#       （此时已经拿完前 i 块石头，第 i 块石头是后放入的石头，值为 prefix[i] ）
#
#       此时考虑先手拿到前 j (0 <= i < j < n) 块石头的情况，
#           1. 如果拿完全部石头，那么先手总分为 prefix[n - 1] ，
#               剩余局面下，后手总分比先手总分多 0 ，
#               所以游戏得分为 prefix[n - 1]
#           2. 如果拿取后至少还剩下一块石头，那么先手总分为 prefix[j] ，
#               剩余局面下，后手总分比先手总分多 dp[j] ，
#               所以游戏得分为 prefix[j] - dp[j]
#
#       综上： dp[i] = max(prefix[n - 1], max(prefix[j] - dp[j])) ，其中 0 <= i < j < n - 1
#             初始化 dp[n - 2] = prefix[n - 1] ，因为此时只剩下两块石头，
#             先手必须全部拿取，先手得分为 prefix[n - 1] ，后手得分为 0 ，游戏得分是 prefix[n - 1]
#
#
#       但这样时间复杂度是 O(n ^ 2) ，还需要继续优化为 O(n)
#
#       我们可以继续考虑： dp[i + 1] = max(dp[n - 1], max(prefix[j] - dp[j])) ，其中 0 <= i + 1 < j < n - 1
#       可以看到 dp[i + 1] 的结果除了 prefix[i + 1] - dp[i + 1] 这个情况都包含了，
#       所以可以优化为 dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])
#       那么最后 dp[0] 就是游戏得分
#
#       由于 dp[i] 由于只与 dp[i + 1] 有关，所以 dp 数组可以优化为 O(1)
#
#       时间复杂度： O(n)
#       空间复杂度： O(n)


class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        n = len(stones)
        # 计算前缀和
        prefix = [0] * n
        prefix[0] = stones[0]
        for i in range(1, n):
            prefix[i] = prefix[i - 1] + stones[i]

        # 初始化 dp[n - 2] ，由于最后剩两块石头，先手必须全部拿取，
        # 先手得分为 prefix[n - 1] ，后手得分为 0 ，游戏得分是 prefix[n - 1]
        dp = prefix[n - 1]
        # 从后往前状态转移计算 dp
        for i in range(n - 3, -1, -1):
            # 1. dp[i] = dp[i + 1] ，包含以下所有情况
            #    包含 max(dp[n - 1], max(prefix[j] - dp[j])) ， 0 <= i + 1 < j < n - 1
            # 2. dp[i] = prefix[i + 1] - dp[i + 1]
            dp = max(dp, prefix[i + 1] - dp)

        return dp
