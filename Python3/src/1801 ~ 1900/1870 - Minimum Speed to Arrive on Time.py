# 链接：https://leetcode.com/problems/minimum-speed-to-arrive-on-time/
# 题意：给定一个整数数组 dist 和一个浮点数 hour ，
#       dist[i] 表明要乘坐的第 i 列火车行驶的记录，
#       hour 表明必须在此及之前乘坐完全部火车，
#       每次只能在整点坐下一辆火车时，且所有火车的行驶速度一样，
#       求所有火车的最小速度是多少？如果无法满足题意，则返回 -1 。

# 数据限制：
#   n == dist.length
#   1 <= n <= 10 ^ 5
#   1 <= dist[i] <= 10 ^ 5
#   1 <= hour <= 10 ^ 9
#   hour 最多有两位小数

# 输入： dist = [1,3,2], hour = 6
# 输出： 1
# 解释：
#   - 第一辆火车耗时 1/1 = 1 小时
#   - 因为已经在一个整点小时，我们可以直接做第二辆火车，第二辆火车耗时 3/1 = 3 小时
#   - 因为已经在一个整点小时，我们可以直接做第三辆火车，第三辆火车耗时 2/1 = 2 小时
#   - 你会在第 6 个小时恰好乘坐玩全部火车


# 输入： dist = [1,3,2], hour = 2.7
# 输出： 3
# 解释：
#   - 第一辆火车耗时 1/3 = 1/3 小时
#   - 因为不在一个整点小时，所以需要等待到第 1 个小时做第二辆火车，第二辆火车耗时 3/3 = 1 小时
#   - 因为已经在一个整点小时，我们可以直接做第三辆火车，第三辆火车耗时 2/3 = 2/3 小时
#   - 你会在第 8/3 ≈ 2.666... 个小时乘坐玩全部火车，在 2.7 之前

# 输入： dist = [1,3,2], hour = 1.9
# 输出： -1
# 解释：
#   乘坐完全部三辆火车至少要 2+ 个小时，但是需要在 1.9 个小时之前乘坐完全部火车，所以无法满足题意。

# 思路： 二分
#
#       我们二分速度，题目保证速度不超过 10 ^ 7 ，所以我们可以设定二分的范围为 [1, 10 ^ 7] 。
#       用函数 check(speed) 来判断是否满足题意，每一辆火车用时计算方式为：
#           1. 非最后一辆火车： math.ceil(dist[i] / speed)
#           2. 最后一辆火车： dist[i] / speed
#       最后求和这些用时为 res ，返回 res <= hour 即可
#
#       如果 check(mid) 成立，则更新 r = mid - 1 ，否则 l = mid + 1
#       二分终止条件为 l <= r ，最终 l 就是我们要求的最小速度。
#       返回前需要判断 l 是否大于 10 ^ 7 ，如果大于，则不满足题意，返回 -1 ，否则返回 l
#       
#       时间复杂度： O(mlogn) ，其中 m = 10 ^ 7
#       空间复杂度： O(1)


MAX_SPEED = 10000000


class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        def check(speed: int):
            """判断给定的速度是否满足题意"""
            res = 0
            # 非最后一辆火车的用时需要向上取整
            for i in range(len(dist) - 1):
                res += math.ceil(dist[i] / speed)
            # 最后一辆火车的用时直接计算即可
            res += dist[-1] / speed
            # 只要总用时不超过 hour 就满足题意
            return res <= hour

        # 二分速度，题目保证速度不超过 10 ^ 7
        l, r = 1, MAX_SPEED
        # 使用闭区间形式，二分终止条件为 l <= r 
        while l <= r:
            mid = (l + r) >> 1
            # 如果 mid 满足题意，则 [l, mid] 存在满足题意的速度，
            # 下次二分 [l, mid - 1]
            if check(mid):
                r = mid - 1
            else:
                # 如果 mid 不满足题意，则 [l, mid] 均不满足题意，
                # 下次二分 [mid + 1, r]
                l = mid + 1

        # 如果 l 超过了最大速度，则必定不满足题意，直接返回 -1 ，否则返回 l
        return -1 if l > MAX_SPEED else l
