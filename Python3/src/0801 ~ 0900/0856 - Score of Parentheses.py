# 链接：https://leetcode.com/problems/score-of-parentheses/
# 题意：给定一个合法的括号字符串，求它的分数。
#      
#      分数计算规则如下：
#          1. "()" 的得分是 1
#          2. AB 的分数是 score(A) + score(B) ，
#              其中 A 和 B 都是合法的括号字符串
#          3. (A) 的分数是 2 * score(A) ，
#              其中 A 是合法的括号字符串


# 数据限制：
#   2 <= s.length <= 50
#   s 仅由 '(' 和 ')' 组成
#   s 是一个合法的括号字符串


# 输入： s = "()"
# 输出： 1
# 解释： "()" 的得分是 1

# 输入： s = "(())"
# 输出： 2
# 解释： "(())" 可以运用规则 3 ，拆分成 (A) 的形式，
#       得分是 2 * 1 = 2

# 输入： s = "()()"
# 输出： 2
# 解释： "()()" 可以运用规则 2 ，拆分成 AB 的形式，
#       得分是 1 + 1 = 2


# 思路1： 栈
#
#       只能想到 O(n ^ 2) 的分治方法，有往栈的方向想，但没绕明白。
#   
#       看了讨论区基于栈的解法才恍然大悟，其实主要还是针对三种情况计算即可。
#   
#       我们使用一个栈 stack 维护每一层括号内的分数和，
#       初始放入一个 0 ，方便后续不用处理边界情况。
#   
#       遍历 s 中的每个括号，按照如下方法处理即可：
#           1. 如果是左括号 '(' ，则表明表示进入下一层括号，
#               放入 0 ，用于收集这一层括号内的分数和
#           2. 如果是右括号 ')' ，
#               则栈顶分数是当前要闭合的括号内的分数 inner_score ，
#               有两种可能：
#               (1) 形如 (): 则表明是第一种情况，此时 inner_score 必定为 0
#               (2) 形如 (A): 则表明是第三种情况，此时 inner_score 必定不为 0
#   
#               综合这两种可能，那么此时要闭合的括号的分数为：
#               cur_score = max(inner_score * 2, 1)
#   
#               然后我们还要计算它所在层的分数和，即次栈顶就是当前层的分数和，
#               我们把 cur_score 的分数加到次栈顶即可。
#   
#        最后，栈 stack 中只有一个分数，就是所有括号的分数和
#
#
#       我们用 "(()(()))" 这个用例实际模拟一遍：
#           [0]:            初始放入一个 0
#           [0, 0]:         遇见 '(' ，放入 0
#           [0, 0, 0]:      遇见 '(' ，放入 0
#           [0, 1]:         遇见 ')' ，此时要计算要闭合的括号所在层的分数和。
#   
#                           栈顶分数表示要闭合的括号内的分数和，
#                           分数 0 表示是 () 这种情况，内部没有括号，所以分数为 1
#   
#                           次栈顶分数表示闭合括号所在层的分数和，目前是 0 ，
#                           分数加在一起就是 0 + 1 = 1
#           [0, 1, 0]:      遇见 '(' ，放入 0
#           [0, 1, 0, 0]:   遇见 '(' ，放入 0
#           [0, 1, 1]:      遇见 ')' ，此时要计算要闭合的括号所在层的分数和。
#   
#                           栈顶分数表示要闭合的括号内的分数和，
#                           分数 0 表示是 () 这种情况，内部没有括号，所以分数为 1
#   
#                           次栈顶分数表示闭合括号所在层的分数和，目前是 0 ，
#                           分数加在一起就是 0 + 1 = 1
#           [0, 3]:         遇见 ')' ，此时要计算要闭合的括号所在层的分数和。
#   
#                           栈顶分数表示要闭合的括号内的分数和，
#                           分数 1 表示是 (()) 这种情况，内部有括号，所以分数乘 2
#   
#                           次栈顶分数表示闭合括号所在层的分数和，目前是 1 ，
#                           分数加在一起就是 1 + 1 * 2 = 3
#           [6]:            遇见 ')' ，此时要计算要闭合的括号所在层的分数和。
#   
#                           栈顶分数表示要闭合的括号内的分数和，
#                           分数 3 表示是 (A) 这种情况，内部有括号，所以分数乘 2
#   
#                           次栈顶分数表示闭合括号所在层的分数和，目前是 0 ，
#                           分数加在一起就是 0 + 3 * 2 = 6
#
#
#		时间复杂度： O(n)
#           1. 需要遍历 s 中的全部 O(n) 个字符
#		空间复杂度： O(n)
#           1. 需要记录左括号对应的分数，最差情况下有 O(n) 个连续的左括号


class Solution:
    def scoreOfParentheses(self, s: str) -> int:
        # 记录每一个对括号内的分数
        # 初始放入 0 ，表示最左侧的括号前有一个左括号，
        # 方便后续处理，这样无需判断最外层括号的边界条件
        stack: List[int] = [0]
        # 遍历每个括号
        for ch in s:
            if ch == '(':
                # 如果是左括号，则表明表示进入下一层括号，
                # 放入 0 ，用于收集这一层括号内的分数和
                stack.append(0)
            else:
                # 其他情况则必定是右括号

                # 获取当前要闭合的括号内的分数，有两种情况：
                #  1. (): 则表明是第一种情况，此时内部分数必定为 0
                #  2. (A): 则表明是第三种情况，此时内部分数必定不为 0
                inner_score: int = stack.pop()
                # 综上，当前要闭合的括号的分数为： max(inner_score * 2, 1)
                cur_score: int = max(inner_score << 1, 1)
                # 获取当前要闭合的括号所在层的分数和
                score_sum: int = stack.pop()
                # 此时处理形如 AB 的第二种情况，
                # 即当前一层括号内的分数和为： score_sum + cur_score ，
                # 放入 stack 中，用于后续处理
                stack.append(score_sum + cur_score)

        # 现在栈中只有一个分数，就是所有括号的分数和
        return stack.pop()
