# 链接：https://leetcode.com/problems/longest-nice-subarray/
# 题意：给定一个正整数数组 nums ，求满足以下条件的最长子数组的长度？
#      该子数组中任意两个数之间的按位与都是 0 。


# 数据限制：
#  1 <= nums.length <= 10 ^ 5
#  1 <= nums[i] <= 10 ^ 9


# 输入： nums = [1,3,8,48,10]
# 输出： 3
# 解释： 满足题意的最长子数组为 [3,8,48]
#       - 3 & 8 = 0
#       - 8 & 48 = 0
#       - 3 & 48 = 0

# 输入： nums = [3,1,5,11,13]
# 输出： 1
# 解释： 所有数都是奇数，最低位都为 1 ，所以满足题意的最长子数组长度为 1 。


# 思路： 滑动窗口
#
#      如果一道题目需要在所有满足某种状态的连续子串/连续子数组中，
#      找到满足题意的一个，那么可以考虑滑动窗口。
#
#      本题需要在所有任意两个数之间的按位与都是 0 的连续子数组中，找到最长的那个。
#
#      那么我们使用滑动窗口 [l, r] 表示一个任意两个数之间的按位与都是 0 的连续子数组，
#      初始化为左边界 l = 0 ，右边界 r = -1 ，表示初始窗口为空。
#
#      然后不断右移右边界 r ，准备将其纳入到滑动窗口中考虑。
#
#      题目是需要保证连续子数组的任意两个数之间的按位与都是 0 ，
#      所以我们贪心地尽可能不缩小滑动窗口，除非 s[r] 与滑动窗口中的某个数按位与不为 0 。
#
#      因此，我们需要在 [l, r - 1] 内找到最后一个与 s[r] 按位与不为 0 的数 s[ll] ，
#      那么以 r 为右边界的最大滑动窗口为 [ll + 1, r] ，大小为 r - l + 1 。
#
#      【注意】题目要求按位与为 0 保证滑动窗口的大小最大为 O(C) ，
#      所以每次右移右边界后，最多遍历滑动窗口内的 O(C) 个数。
#
#      我们统计所有滑动窗口的大小的最大值到 ans 中，
#      则 ans 就是满足题意的最长连续子数组的长度。
#
#
#      设整数的二进制位个数为 C 。
#
#      时间复杂度：O(nC)
#          1. 需要右移滑动窗口右边界 O(n) 次，每次最多遍历滑动窗口内的 O(C) 个数。
#      空间复杂度：O(1)
#          1. 只需要维护常数个额外变量即可


class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        # ans 维护满足题意的最长子数组的长度
        ans: int = 0
        # 滑动窗口左边界
        l: int = 0
        # 不断右移滑动窗口右边界
        for r in range(len(nums)):
            # 找到最后一个与 s[r] 按位与不为 0 的数 s[ll]
            ll: int = r - 1
            while ll >= l and (nums[r] & nums[ll] == 0):
                ll -= 1

            # 以 r 为右边界的最大滑动窗口为 [ll + 1, r]
            l = ll + 1
            # 更新滑动窗口大小的最大值
            ans = max(ans, r - l + 1)

        return ans
