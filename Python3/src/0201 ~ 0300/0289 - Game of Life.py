# 链接：https://leetcode.com/problems/game-of-life/
# 题意：给定一个生命游戏的当前状态，修改为下一个状态。
#
#      当前状态由一个 m * n 的二维数组 board 决定，
#      其中 1 代表对应的细胞死亡， 0 代表对应的细胞存活。
# 
#      每个细胞的下一个状态由其附近的 8 个细胞的当前状态决定：
#          1. 任何活细胞周围的活细胞数不足 2 个时，会死亡
#          2. 任何活细胞周围的活细胞数为 2 或 3 个时，会保持存活
#          3. 任何活细胞周围的活细胞数超过 3 个时，会死亡
#          4. 任何死细胞周围的活细胞数为 3 个时，会复活变成存活状态


# 数据限制：
#  m == board.length
#  n == board[i].length
#  1 <= m, n <= 25
#  board[i][j] 是 0 或 1


# 输入： board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
# 输出： [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

# 输入： board = [[1,1],[1,0]]
# 输出： [[1,1],[1,1]]
# 解释：
#      board[0][0] 是活细胞，周围有 2 个活细胞，所以会保持存活；
#      board[0][1] 是活细胞，周围有 2 个活细胞，所以会保持存活；
#      board[1][0] 是活细胞，周围有 2 个活细胞，所以会保持存活；
#      board[1][1] 是死细胞，周围有 3 个活细胞，所以会复活变为存活状态。


# 思路： 模拟 + 状态压缩
#
#      我们可以使用两位二进制位来表示每个细胞的当前状态和下一个状态：
#
#      1. 最低位表示当前状态，
#          state & 1 为 1 表示当前状态为存活，
#          state & 1 为 0 表示当前状态为死亡；
#      2. 次低位表示下一个状态，
#          state & 2 为 2 表示下一个状态为存活，
#          state & 2 为 0 表示下一个状态为死亡。
#
#      然后我们枚举每一个细胞，统计其周围的当前存活细胞数，
#      再根据生命游戏的规则，更新其下一个状态。
#
#      最后我们再将每个细胞的下一个状态转为当前状态。
#
#
#      时间复杂度：O(m * n)
#          1. 需要遍历 board 中全部 O(m * n) 个细胞
#      空间复杂度：O(1)
#          1. 只需要维护常数个额外变量


# 8 个方向的位置改变量
DIRS: List[Tuple[int, int]] = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]


class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        m: int = len(board)
        n: int = len(board[0])
        # 枚举每一个细胞
        for r in range(m):
            for c in range(n):
                # 统计当前细胞周围的存活细胞数
                liveCells: int = 0
                for dr, dc in DIRS:
                    # 计算对应方向的细胞的行列号
                    rr: int = r + dr
                    cc: int = c + dc
                    # 如果未越界，且对应细胞的当前状态是存活，
                    # 则 liveCells 加 1
                    if 0 <= rr < m and 0 <= cc < n:
                        liveCells += board[rr][cc] & 1

                # 下一个状态为存活需要满足以下任意条件：
                #  1. 周围有 3 个存活细胞
                #  2. 当前是活细胞，且周围有 2 个活细胞
                if liveCells == 3 or (board[r][c] == 1 and liveCells == 2):
                    board[r][c] |= 2

        # 将每个细胞的下一个状态转为当前状态
        for r in range(m):
            for c in range(n):
                board[r][c] >>= 1
