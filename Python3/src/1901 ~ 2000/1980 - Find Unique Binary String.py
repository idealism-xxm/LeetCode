# 链接：https://leetcode.com/problems/find-unique-binary-string/
# 题意：给定 n 个长度为 n 的不同 01 串，返回任意一个不同的长度为 n 的 01 串？

# 数据限制：
#   n == nums.length
#   1 <= n <= 16
#   nums[i].length == n
#   nums[i] 是 '0' 或 '1'
#   所有的 nums 都不同

# 输入： nums = ["01","10"]
# 输出： "11"
# 解释： 
#       "00" 和 "11" 都正确

# 输入： nums = ["00","01"]
# 输出： "11"
# 解释： 
#       "10" 和 "11" 都正确

# 输入： nums = ["111","011","001"]
# 输出： "101"
# 解释： 
#       "000", "010", "100", "101", "110" 都正确

# 思路： 对角线证法
#
#       比赛的时候先构建了 trie ，然后每次走个数少的那边，没有就直接跳出循环，
#       最后补足长度 n 即可
#
#       比赛后看到大家讨论，随机一下即可，因为大部分都是没有被使用的
#
#       最后看到了对角线论证法，这个想法很精妙，
#       就是当时康托尔证明全体有理数甚至是全体代数数都是可数的，但全体实数却是不可数
#
#       第一位与第一个数中的第一位不同，即 nums[0][0] == '0' ? '1' : '0' ，
#       第二位与第二个数中的第二位不同，即 nums[1][1] == '0' ? '1' : '0' ，
#       以此类推……
#       这样构建的这个数组和每个数字都存在至少一位不同，那么必定满足题意
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)

class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        ans = ''
        # 保证第 i 位与第 i 个数中的第 i 位不同
        for i, num in enumerate(nums):
            ans += '1' if num[i] == '0' else '0'
        return ans
