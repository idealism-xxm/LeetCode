# 链接：https://leetcode.com/problems/count-number-of-special-subsequences/
# 题意：给定一个只含有 0,1,2 的数字数组，求其中特殊子序列的个数？
#       特殊序列定义：开始是连续的 0 ，然后是连续的 1 ，最后是连续的 2 。


# 数据限制：
#   1 <= nums.length <= 10 ^ 5
#   0 <= nums[i] <= 2

# 输入： nums = [0,1,2,2]
# 输出： 3
# 解释： 
#       [0,1,2,_]
#       [0,1,_,2]
#       [0,1,2,2]

# 输入： nums = [2,2,0,0]
# 输出： 0

# 输入： nums = [0,1,2,0,1,2]
# 输出： 7
# 解释： 
#       [0,1,2,_,_,_]
#       [0,1,_,_,_,2]
#       [0,1,2,_,_,2]
#       [0,1,_,_,1,2]
#       [0,_,_,0,1,2]
#       [0,_,_,_,1,2]
#       [_,_,_,0,1,2]



# 思路： DP
#
#       设 dp[i][j] 表示前 i 个数形成的子序列中以 j 为尾的特殊子序列的个数，
#       初始化 dp[0][0] = int(nums[i] == 0) ， dp[0][1] = dp[0][2] = 0
#       状态转移：
#           1. nums[i] == 0: dp[i][0] = dp[i - 1][0] * 2 + 1
#               (1) 使用前面的 0 序列，共有两种方式：选或者不选当前 0
#               (2) 不使用前面的 0 序列，只有一种方式：选当前 0
#           2. nums[i] == 1: dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0]
#               (1) 使用前面的 1 序列，共有两种方式：选或者不选当前 1
#               (2) 使用前面的 0 序列，只有一种方式：选当前 1
#           3. nums[i] == 2: dp[i][0] = dp[i - 1][0] * 2 + dp[i - 1][1]
#               (1) 使用前面的 2序列，共有两种方式：选或者不选当前 2
#               (2) 使用前面的 1 序列，只有一种方式：选当前 2
#
#       由于状态转移时只与前一个有关，其他的会直接复制，所以可以优化为一维数组
#       dp[j] 表示以 j 为结尾的特殊子序列的个数
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)

MOD = 1000000007


class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0, 0, 0]
        for num in nums:
            if num == 0:
                # 1. 使用前面的 0 序列，共有两种方式：选或者不选当前 0
                # 2. 不使用前面的 1 序列，只有一种方式：选当前 0
                dp[0] = ((dp[0] << 1) + 1) % MOD
            else:
                # 1. 使用前面的 num 序列，共有两种方式：选或者不选当前 num
                # 2. 使用前面的 num - 1 序列，只有一种方式：选当前 num
                dp[num] = ((dp[num] << 1) + dp[num - 1]) % MOD

        return dp[2]
