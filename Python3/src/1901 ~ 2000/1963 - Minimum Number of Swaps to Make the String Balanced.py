# 链接：https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/
# 题意：给定一个偶数长度的字符串 s ，其中一半是 '[' ，另一半是 ']' ，
#       每次可交换任意两个位置的字符，求最少交换多少次可以使其变为一个合法的括号序列？

# 数据限制：
#   n == s.length
#   2 <= n <= 10 ^ 6
#   n 是偶数
#   s[i] 是 '[' 或 ']'
#   '[' 和 ']' 的数量都是 n / 2

# 输入： s = "][]["
# 输出： 1
# 解释： "][][" -> "[[]]"

# 输入： s = "]]][[["
# 输出： 2
# 解释： "]]][[[" -> "[]][[]" -> "[[][]]"

# 输入： s = "[]"
# 输出： 0


# 思路1： 贪心
#
#       前括号和后括号个数相等，所以我们贪心地配对后括号即可，
#       如果当前后括号没有可配对的前括号，则需要找到最后一个前括号与其交换，
#       因为最后一个前括号更容易出现未匹配上的后括号
#
#       时间复杂度： O(n)
#       空间复杂度： O(n)

class Solution:
    def minSwaps(self, s: str) -> int:
        # 统计交换次数
        ans = 0
        # 统计当前还剩多少个前括号未配对
        cnt = 0
        n, chs = len(s), list(s)
        # 最后一个前括号可能的位置
        last = n - 1
        for i in range(n):
            ch = chs[i]
            # 如果当前是前括号，则 cnt += 1
            if ch == '[':
                cnt += 1
            elif cnt > 0:
                # 如果当前是后括号，且有可配对的前括号，则 cnt -= 1
                cnt -= 1
            else:
                # 如果当前是后括号，且没有可配对的前括号，
                # 则需要找到最后一个前括号，并且交换
                while last > i and chs[last] == ']':
                    last -= 1
                chs[last] = '['
                ans += 1
                # 此时当前变为前括号，cnt += 1
                cnt += 1
        return ans


# 思路2： 贪心
#
#       思路1 进一步思考：
#
#       实际上我们并不需要实际去交换，这样我们就不需要 O(n) 的额外空间了。
#       按照思路1 中的方式，我们每次都会交换最后一个前括号，
#       那么遍历到第一个被交换后的后括号时，剩下的都是后括号，即 ...]]] ，
#       而这时前面的前括号必定都能与其匹配上，因为 s 中前后括号数量相等，
#       因此这些位置即使是前括号也无妨
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)

class Solution:
    def minSwaps(self, s: str) -> int:
        # 统计交换次数
        ans = 0
        # 统计当前还剩多少个前括号未配对
        cnt = 0
        for ch in s:
            # 如果当前是前括号，则 cnt += 1
            if ch == '[':
                cnt += 1
            elif cnt > 0:
                # 如果当前是后括号，且有可配对的前括号，则 cnt -= 1
                cnt -= 1
            else:
                # 假装后最后一个前括号交换
                ans += 1
                # 此时当前变为前括号，cnt += 1
                cnt += 1
        return ans
