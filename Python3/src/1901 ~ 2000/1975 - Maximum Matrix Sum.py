# 链接：https://leetcode.com/problems/maximum-matrix-sum/
# 题意：给定一个 m * n 的矩阵 matrix ，每次可以选择两个边相连的元素，
#       对它们都乘 -1 ，你可以进行任意次这样的操作，
#       求最终的矩阵的所有元素的和最大值？

# 数据限制：
#   n == matrix.length == matrix[i].length
#   2 <= n <= 250
#   -10 ^ 5 <= matrix[i][j] <= 10 ^ 5

# 输入： matrix = [[1,-1],[-1,1]]
# 输出： 4
# 解释： 
#       1, -1    ->    -1, 1    ->    1, 1
#      -1,  1          -1, 1          1, 1

# 输入： matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
# 输出： 16
# 解释： 
#        1,  2,  3           1, 2, 3
#       -1, -2, -3    ->    -1, 2, 3
#        1,  2,  3           1, 2, 3


# 思路： 贪心
#
#       1. 选择的两个数都是负数：可以消除两个负号
#       2. 选择的两个数一正一负：可以讲负号移动位置
#       3. 选择的两个数都是整数：可以增加两个负号（无意义，不使用）
#
#       基于 1, 2 两点，我们可以经过有限次操作，将任意两个负数变为正数
#       1. 如果有偶数个负数，那么所有负数都可以变为正数，答案为所有数的绝对值之和 sm
#       2. 如果有奇数个负数，那么最后必定还剩下一个负数，
#           那么为了得到最大值，我们可以将这个负号移动到绝对值最小的数 mn 那里，
#           答案为 sm - mn - mn （第一次是为了从总和总减去多加的绝对值，第二次是该负数的贡献）
#
#
#       时间复杂度： O(|word|)
#       空间复杂度： O(1)

class Solution:
    def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        # 记录所有数的绝对值之和 以及 绝对值的最小值
        sm = 0
        mn = 1000000
        # 记录负数的个数
        neg_cnt = 0
        for row in matrix:
            for num in row:
                # 如果该数是负数，那么取相反数，并 neg_cnt + 1
                if num < 0:
                    num = -num
                    neg_cnt += 1
                # 记录绝对值之和 和 绝对值的最小值
                sm += num
                mn = min(mn, num)

        # 如果有奇数个负数，那么需要将去两倍的 mn
        if neg_cnt & 1:
            sm -= mn * 2
        return sm
