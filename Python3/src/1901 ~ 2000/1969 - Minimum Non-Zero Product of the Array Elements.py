# 链接：https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/
# 题意：给定一个正数 p ，得到一个数组 nums ，包含 [1, 2 ^ p] 内所有数，
#       现在可以执行以下操作任意次，求最后所有数乘积的非零最小值？
#           1. 从 nums 中选择两个数 x 和 y
#           2. 交换 x 和 y 的二进制下的相同位

# 数据限制：
#   1 <= p <= 60

# 输入： p = 1
# 输出： 1
# 解释： 
#       nums = [1]

# 输入： p = 2
# 输出： 6
# 解释： （nums 由二进制表示）
#       nums = [01, 10, 11]
#       操作后： nums = [01, 10, 11]
#           1 * 2 * 3 = 6

# 输入： p = 3
# 输出： 1512
# 解释： 
#       （nums 由二进制表示）
#       nums = [001, 010, 011, 100, 101, 110, 111]
#       操作后： nums = [001, 110, 011, 100, 001, 110, 111]
#           1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512


# 思路： 贪心
#
#       观察题目给定的样例，可以猜测一个规律：
#           1. 最大的 (2 ^ p) - 1 一定会在结果中，
#           2. 剩下的 (2 ^ p) - 2 个数，会形成 (2 ^ (p - 1) - 1) 对的组合，
#               每个组合都是两个数： 1 和 (2 ^ p) - 2
#
#       简单说明：
#           对于 p 总共有 (2 ^ p) - 1 个数，其中最大的 (2 ^ p) - 1 自成一组，
#           剩余的 (2 ^ p) - 2 个数，会形成 (2 ^ (p - 1) - 1) 个组合，每对组合的和都是 (2 ^ p) - 1 ，
#           针对一个组合 a 和 b ，假设 a < b （a 不可能等于 b ，因为 (2 ^ p) - 1 是奇数），
#           它们的积位 a * b ，现在从把 a 的一个二进制 1 放到 b 上，设这个二进制 1 代表十进制 x，
#           则有 (a - x) * (b + x) = a * b + a * x - b * x - x * x
#                                 < a * b + b * x - b * x - x * x
#                                 = a * b - x * x
#                                 < a * b
#           那么只要把 a 的二进制位尽可能全给 b ，那么此时他们的积最小，
#           那么此时 a = 1, b = (2 ^ p) - 2，那么积就是 (2 ^ p) - 2
#
#           对于 (2 ^ p) - 1 自身来说，没有配对的数，所以最终需要乘在答案上
#       
#       时间复杂度： O(p)
#       空间复杂度： O(1)


MOD = 1000000007


class Solution:
    def minNonZeroProduct(self, p: int) -> int:
        if p == 1:
            return 1

        mx = (1 << p) - 1
        # 按照公式计算即可
        return (self.quick_pow(mx - 1, (1 << (p - 1)) - 1) * mx) % MOD
    
    def quick_pow(self, x: int, y: int) -> int:
        """快速幂"""
        res = 1
        while y > 0:
            if y & 1:
                res = (res * x) % MOD
            x = (x * x) % MOD
            y >>= 1

        return res
