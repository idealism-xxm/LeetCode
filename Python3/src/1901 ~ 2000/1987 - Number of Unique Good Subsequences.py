# 链接：https://leetcode.com/problems/number-of-unique-good-subsequences/
# 题意：给定一个 01 串，求不同的好子序列的个数？
#       好子序列：不含前导零的 01 串
#       不同：子序列形成的 01 串不同

# 数据限制：
#   1 <= binary.length <= 10 ^ 5
#   binary 仅由 01 组成

# 输入： binary = "001"
# 输出： 2
# 解释： 
#       所有的好子序列为 ["0", "0", "1"] ，
#       所有不同的好子序列为 ["0", "1"]

# 输入： binary = "11"
# 输出： 2
# 解释： 
#       所有的好子序列为 ["1", "1", "11"] ，
#       所有不同的好子序列为 ["1", "11"]

# 输入： binary = "101"
# 输出： 5
# 解释： 
#       所有的好子序列为 ["1", "0", "1", "10", "11", "101"]
#       所有不同的好子序列为 ["1", "0", "10", "11", "101"]


# 思路： DP
#
#       这种需要统筹前面所有状态的很少接触，特别是需要去重这块，
#       比赛时发现了经典的题 [940. Distinct Subsequences II](https://leetcode.com/problems/distinct-subsequences-ii/) 
#       才学会如何处理
#
#       比赛结束后又学习了大家不同的解法
#
#       设 dp[i][j] 表示 binary[:i] 中以 j 为结尾的不同好子序列的个数，
#       （只统计以 1 开始的， 0 单独处理）
#
#       初始化： dp[0][0] = dp[0][1] = 0
#       状态转移：
#           1. 当前字符是 '0'
#               (1) 对以 0 和 1 结尾的不同好子序列尾部，都加上 0 即可，
#                   不需要其他处理，因为已经包含了所有情况，且无重复计算。
#                   ① dp[i - 1][0]: 对此再加上 0 ，形成的好子序列的末尾至少有 2 个 0
#                   ② dp[i - 1][1]: 对此再加上 0 ，形成的好子序列的末尾都只有 1 个 0
#
#                   dp[i][0] = dp[i - 1][0] + dp[i - 1][1]
#
#               (2) 当前字符不是 1 ，所以不能选择它，那么直接从 dp[i - 1][1] 转移
#                   dp[i][1] = dp[i - 1][1]
#
#           2. 当前字符是 '1'
#               (1) 当前字符不是 0 ，所以不能选择它，那么直接从 dp[i - 1][0] 转移
#                   dp[i][0] = dp[i - 1][0]
#
#               (2) 对以 0 和 1 结尾的不同好子序列尾部，都加上 1 ，
#                   还有一种情况就是以当前的 1 开头形成新的好子序列。
#                   ① dp[i - 1][0]: 对此再加上 1 ，形成的好子序列的末尾至少有 2 个 1
#                   ② dp[i - 1][1]: 对此再加上 1 ，形成的好子序列的末尾都只有 1 个 1
#                   ③ 1: 前面的好子序列长度至少为 2 ，还差长度为 1 的 "1" 本身
#
#                   dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + 1
#
#       由于每次状态转移都与前一个有关，所以空间复杂度可以优化为 O(1)
#       状态转移方程也可以进行简化
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)


MOD = 1000000007


class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        # 标记字符串中是否有 0
        has_zero = False
        # 统计前缀中是以 1 开头以 j 结尾的不同好子序列的个数
        dp = [0, 0]
        for ch in binary:
            if ch == '0':
                has_zero = True
                # 在前面所有的好子序列的末尾加上 0 即可
                # 1. dp[0] 转移而来的末尾至少两个 0
                # 2. dp[1] 转移而来的末尾只有一个 0
                dp[0] = (dp[0] + dp[1]) % MOD
            else:
                # 在前面所有的好子序列的末尾加上 0 即可，并算上 "1" 本身
                # 1. dp[0] 转移而来的末尾至少两个 0
                # 2. dp[1] 转移而来的末尾只有一个 0
                # 3. 1 表示 "1" 本身就是好子序列（前两种长度至少为 2）
                dp[1] = (dp[0] + dp[1] + 1) % MOD
        # 如果含有 0 ，则需要单独加上 0 本身
        if has_zero:
            return (dp[0] + dp[1] + 1) % MOD

        return dp[0] + dp[1]
