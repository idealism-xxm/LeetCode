# 链接：https://leetcode.com/problems/grid-game/
# 题意：给定一个 2 * n 的二维数组，每个位置有一个点数，有两个机器人要从 (0, 0) 走到 (1, n - 1) ，
#       它们每次可以向右移动一格 或者 向下移动一格，每次到达一个位置都会收集该位置的点数，
#       并将该位置的点数置为 0 。
#       第一个机器人先走，它的目标是让第二个机器人收集的点数最小，
#       第二个机器人后走，它的目标是让自己收集的点数最大，求第二个机器人最大能收集多少点数？

# 数据限制：
#   grid.length == 2
#   n == grid[r].length
#   1 <= n <= 5 * 10 ^ 4
#   1 <= grid[r][c] <= 10 ^ 5

# 输入： grid = [[2,5,4],[1,5,1]]
# 输出： 4
# 解释：
#   第一个机器人最优方式是按如下方式走：
#       (2),(5), 4
#        1 ,(5),(1)
#   第二个机器人最优方式是按如下方式走：
#       (0),(0),(4)
#        1 , 0 ,(0)

# 输入： grid = [[3,3,1],[8,5,2]]
# 输出： 4
# 解释：
#   第一个机器人最优方式是按如下方式走：
#       (3), 3 , 1
#       (8),(5),(2)
#   第二个机器人最优方式是按如下方式走：
#       (0),(3),(1)
#        0 , 0 ,(0)

# 输入： grid = [[1,3,1,15],[1,3,3,1]]
# 输出： 7
# 解释：
#   第一个机器人最优方式是按如下方式走：
#       (1),(3),(1),(15)
#        1 , 3 , 3 ,(1)
#   第二个机器人最优方式是按如下方式走：
#       (1), 0 , 0 , 0
#       (1),(3),(3),(1)


# 思路： 前缀和
#
#       由于数组是 2 * n ，且机器人要从左上角走到右下角，
#       那么两个机器人必定是现在第一行走前半段，再在第二行走后半段，
#       假设第一个机器人在第 i 列往下走，
#       那么第二个机器人的走法必定只有两种：
#       （如果在其他位置往下走，必定不会更优，因为存在多余的为 0 的位置）
#           1. 走完第一行全部 n 列，最后再往下走，此时收集的点数为： sum(grid[0][i + 1:])
#           2. 先往下走，再走完第二行全部 n 列，此时收集的点数为： sum(grid[1][:i])
#       那么第二个机器人在这种情况下最大能收集的点数为： max(sum(grid[0][i + 1:]), sum(grid[1][:i]))
#
#       但第一个机器人的目标是要让第二个机器人收集的点数最小，所以枚举所有点，
#       然后求每种情况下第二个机器人的最大收集点数的最小值即可
#
#       由于数据量比较大，所以可以使用前缀和维护第一行的总和，然后不断减去；
#       第二行则不断加上当前点数即可
#
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)


class Solution:
    def gridGame(self, grid: List[List[int]]) -> int:
        # top_sum 维护 sum(grid[0][i + 1:]) 的和，不断从第一行中的总和减去当前点数
        top_sum = sum(grid[0])
        # bottom_sum 维护 sum(grid[1][:i]) 的和，加上当前点数
        bottom_sum  = 0
        # ans 表示第二个机器人收集的点数的最小值
        ans = 10000000000
        # 枚举第一个机器人向下走的位置
        for i in range(len(grid[0])):
            # 此时第 i 列的点数会被第一个机器人收集，需要优先减去
            top_sum -= grid[0][i]
            # 第二个机器人这种情况下最多能收集的点数为 max(top_sum, bottom_sum)
            # 第一个机器人要让第二个机器人收集的点数最小，所以选择这些情况中的最小值
            ans = min(ans, max(top_sum, bottom_sum))
            # 此后第 i 列的点数才不会被第一个机器人手机，可以加上
            bottom_sum += grid[1][i]
        return ans
