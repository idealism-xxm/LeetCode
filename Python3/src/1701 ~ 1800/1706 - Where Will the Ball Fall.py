# 链接：https://leetcode.com/problems/where-will-the-ball-fall/
# 题意：给定一个 m * n 的盒子 grid ，
#      盒子的每一个单元格 (r, c) 都有一个跨过单元格两角的挡板：
#          1. grid[r][c] 为 1 表示有一个跨过左上角和右下角的挡板，
#              能将球导向右则
#          2. grid[r][c] 为 -1 表示有一个跨过右上角和左下角的挡板，
#              能将球导向左则
#
#      初始有 n 个球，第 i 个球初始在 (0, i) 处，
#      求每个球最终会从箱子底部的哪一列出来？
#      如果由于卡住而不能从箱子底部出来，则用 -1 表示。
#
#      以下情况会导致求被卡住：
#          1. 球恰好在两块挡板形成的 'V' 形图案中
#          2. 球恰好被一块挡板导向箱子的侧边上


# 数据限制：
#  m == grid.length
#  n == grid[i].length
#  1 <= m, n <= 100
#  grid[i][j] 是 1 或 -1


# 输入： grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
# 输出： [1,-1,-1,-1,-1]
# 解释： 第 0 个球会从箱子底部第 1 列出来。
#       第 1 个球卡在第 1 行第 2 列和第 3 列形成的 'V' 形图案中。
#       第 2 个球卡在第 0 行第 2 列和第 3 列形成的 'V' 形图案中。   
#       第 3 个球卡在第 0 行第 2 列和第 3 列形成的 'V' 形图案中。
#       第 4 个球卡在第 1 行第 2 列和第 3 列形成的 'V' 形图案中。

# 输入： grid = [[-1]]
# 输出： [-1]
# 解释： 第 0 个球会卡在第 0 行第 0 列与箱子左侧边出。

# 输入： grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
# 输出： [0,1,2,3,4,-1]


# 思路： 模拟
#
#      我们可以直接模拟每一个球的运动轨迹。
#
#      对于位于 (r, c) 处的球，根据 grid[r][c] 的值，我们就能确定它的动向：
#          1. grid[r][c] 为 -1 ，则球可能会向左导向 (r + 1, c - 1) 处
#          2. grid[r][c] 为 1 ，则球可能会向右导向 (r + 1, c + 1) 处
#
#      综上，位于 (r, c) 处的球，可能会导向 (r + 1, cc) 处，
#      其中 cc =  + grid[r][c] 。
#
#      在此基础上还需要考虑被卡住的两种情况：
#          1. 球恰好在两块挡板形成的 'V' 形图案中：
#              此时 (r, c) 和 (r, cc) 两处的挡板方向相反，
#              即 grid[r][c] != grid[r][cc]
#          2. 球恰好被一块挡板导向箱子的侧边上：
#              此时 cc 超出了箱子边界，即 cc < 0 || cc >= n
#
#      如果未遇到以上两种情况，则球不会被卡住，能正常导向 (r + 1, cc) 处。
#
#
#      时间复杂度：O(mn)
#          1. 需要对全部 O(n) 个球进行模拟，每次需要都需要遍历全部 O(m) 行
#      空间复杂度：O(1)
#          1. 只需要使用常数个额外变量即可


class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        n: int = len(grid[0])
        ans: List[int] = []
        # 枚举每个球，模拟其运动轨迹
        for c in range(n):
            ans.append(Solution.get_final_column(grid, c))
        return ans
    
    @staticmethod
    def get_final_column(grid: List[List[int]], c: int) -> int:
        m, n = len(grid), len(grid[0])
        # 模拟初始在 (0, c) 处的球的运动轨迹
        for r in range(m):
            # 计算 (r, c) 处的球可能导向的位置
            cc: int = c + grid[r][c]
            # 如果导向了箱子侧边 (cc < 0 || cc >= n) ，
            # 或导向了 'V' 形图案 (grid[r][c] != grid[r][cc]) ，
            # 则球会被卡在此处，返回 -1
            if cc < 0 or cc >= n or grid[r][c] != grid[r][cc]:
                return -1
            # 未被卡住的情况下，球会正常导向 (r + 1, cc)
            c = cc

        # 此时球未被卡住，能从底部第 c 列出来
        return c
