# 链接：https://leetcode.com/problems/stone-game-ix/
# 题意：给定一个数组 stones ，表示 n 堆石头的个数，现在两个人轮流拿取石头，每次拿取一堆，
#       如果某个人拿取完石头后，所有被拿取的石头的数量和是 3 的倍数，则另一个人获胜，
#       如果最后拿取完所有的石头，且石头总数不是 3 的倍数，则后手获胜。
#       现在两个人都以最优的策略拿取石头，判断是否先手必胜？

# 数据限制：
#   1 <= stones.length <= 10 ^ 5
#   1 <= stones[i] <= 10 ^ 4


# 输入： stones = [2,1]
# 输出： true
# 解释：
#   - 先手拿 1 ，总共拿取 1 块石头
#   - 后手拿 2 ，总共拿取 3 块石头，是 3 的倍数，则先手获胜

# 输入： stones = [2]
# 输出： false
# 解释：
#   - 先手拿 2 ，总共拿取 2 块石头，所有石头已被拿取完，但是总数不是 3 的倍数，则后手获胜

# 输入： stones = [5,1,2,4,3]
# 输出： false
# 解释：
#   - 先手拿 1 ，总共拿取  1 块石头
#   - 后手拿 3 ，总共拿取  4 块石头
#   - 先手拿 4 ，总共拿取  8 块石头
#   - 后手拿 2 ，总共拿取 10 块石头
#   - 先手拿 5 ，总共拿取 15 块石头，总数是 3 的倍数，则后手获胜


# 思路： 博弈
#
#       由于判断胜负的条件是看总是是否是 3 的倍数，我们可以先将所有的石头数量模 3 ，
#       规约成 0, 1, 2 的数组，方便后续处理
#
#       我们先不考虑有 0 的情况，即只含有 1 和 2 的数组，
#           (1) 如果先手拿了 1 ，则完整拿取序列只能为： 1, 1, 2, 1, 2, 1, ...
#           (2) 如果先手拿了 2 ，则完整拿取序列只能为： 2, 2, 1, 2, 1, 2, ...
#       针对这两种情况，如果有一步，这个人不能拿取指定的石头，则另一个人获胜。
#       如果最后所有的石头都能拿完，则后手获胜
#
#       现在考虑有 0 的情况，因为 0 不会影响模 3 的结果，所以当一个人拿取了 0 的时候，
#       相当于将原本的胜负情况逆转了（除了全部拿完后，后手胜利的这种情况）。
#       那么必胜的那个人绝对不会先拿取 0 ，除非迫不得已。
#       所以必败的那个人会拿取 0 扭转胜负，但只要还有 0 ，必胜的那个人可以再拿取 0 进行抵消。
#           (1) 含有偶数个 0 ：最终结果不会有任何改变，
#               必胜的那个人可以再拿取 0 进行抵消必败的那个人拿取的 0
#           (2) 含有奇数个 0 ：如果必胜的方式不是除了全部拿完后，后手胜利的这种情况，
#               那么必败的那个人必定可以拿取 0 扭转胜负
#
#       先手先拿哪个数字与每个数字的个数有关，
#       令： mn, mx = min(cnt[1], cnt[2]), max(cnt[1], cnt[2])
#       假设： 较小的那个数字时 1 ，较多的那个数字是 2
#       (1) 如果有偶数个 0 ：
#           最终结果不会被改变，先手可以拿先拿 1 ，
#           （由于先手拿的 1 前两次都被拿了，所以即使个数相同，还是会让后手无 1 可拿）
#           这样先手第一次拿了 1 后，后续都会拿 2 ，
#           那么后手拿的 1 必定先被消耗完，而此时先手至少还有一个 2 可拿，先手必胜
#           因此，只要先手能第一次拿 1 ，即 mn > 0 ，则必胜，
#       (2) 如果有奇数个 0 ：
#           最终结果可能会被改变（注意拿完全部数字的这种情况不会改变胜负），
#           根据 (1) 中所得，如果先手第一次拿 1 ，则在偶数个 0 的情况下，先手必胜，
#           但现在有奇数个 0 ，所以先手第一次拿 1 时，先手必败，
#           所以先手第一次只能拿 2
#
#           ① mx - mn == 0 ：由 (1) 可得，此时先手必败
#           ② mx - mn == 1 ：先手第一次拿 2 ，后续必定是先手拿完最后一个 1 ，且此时 2 已经被拿完，
#                             但总和模 3 不为 0 ，所以全部拿完所有石头后，后手获胜
#           ③ mx - mn == 2 ：先手第一次拿 2 ，后续必定是后手拿完最后一个 2 ，且此时 1 已经被拿完，
#                             但总和模 3 不为 0 ，所以全部拿完所有石头后，后手获胜
#           ④ mx - mn >= 3 ：先手第一次拿 2 ，后续必定是先手拿完最后一个 1 ，且此时 2 至少还剩余 2 个，
#                             那么剩余的操作会轮流拿 (cnt[0] + 1) 堆石头（ 2 只会拿一次），
#                             由于后手先开始拿，而 cnt[0] 是奇数，所以 (cnt[0] + 1) 堆石头拿完后，
#                             下一个还是后手开始拿，而此时只有 2 可拿，所以先手必胜
#
#
#       这样分类讨论十分复杂，很容易漏掉或者错判一些情况，所以最简单的方法就是：
#       在知道最前面 0 的作用是反转结果后，枚举先手拿 1 或者 2 ，
#       按照完整序列模拟，判断对应情况下是否先手必胜，
#       如果存在一种必胜的情况，则先手必胜，时间复杂度同样是 O(n)
#                             
#
#       时间复杂度： O(n)
#       空间复杂度： O(1)


class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        # 初始化石头模 3 后的统计数据
        cnt = [0, 0, 0]
        for stone in stones:
            cnt[stone % 3] += 1
        
        # 找到 1 和 2 中的较小者和较大者
        mn, mx = min(cnt[1], cnt[2]), max(cnt[1], cnt[2])
        # 如果有偶数个 0 ，则先手可以拿少的那个，先手必胜
        if cnt[0] & 1 == 0:
            # 先手必须能够拿第一次较少的那个，才能先手必胜
            return mn > 0
        
        # 此时有奇数个 0 ，则先手只能先拿较多的那个，
        # 如果 mx - mn >= 3 ，则先手必胜
        return mx - mn >= 3
