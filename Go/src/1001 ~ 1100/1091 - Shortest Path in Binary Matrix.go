// 链接：https://leetcode.com/problems/shortest-path-in-binary-matrix/
// 题意：给定一个 n * n 的矩阵 grid ，返回其中最短的畅通路径，如果不存在返回 -1 。
//
//      畅通路径满足一下条件：
//          1. 从左上角 (0, 0) 开始，到右下角 (n - 1, n - 1) 结束
//          2. 路径上的的所有单元格的值都是 0
//          3. 所有单元格都是 8 联通的（两个共享同一条边或同一个角的单元格是联通的）


// 数据限制：
//  n == grid.length
//  n == grid[i].length
//  1 <= n <= 100
//  grid[i][j] 是 0 或 1


// 输入： grid = [[0,1],[1,0]]
// 输出： 2
// 解释： (0)  1
//          ↘
//        1  (0)

// 输入： grid = [[0,0,0],[1,1,0],[1,1,0]]
// 输出： 4
// 解释： (0) → (0)  0
//                ↘
//        1     1  (0)
//                  ↓
//        1     1  (0)

// 输入： grid = [[1,0,0],[1,1,0],[1,1,0]]
// 输出： -1


// 思路： BFS
//
//      由于这个图是 8 联通的，各个状态之间不是严格有序的，即无法递推，
//      所以不能使用 DP 。
//
//      但这个图的边权都是 1 ，所以可以直接使用 BFS 找到最短路。
//
//      可以维护一个矩阵 dist ，
//      其中 dist[r][c] 表示从左上角到 (r, c) 的最短畅通路径，
//      初始化为 -1 ，表示不可达。
//
//      再使用一个队列 q 来记录待访问的单元格。
//
//      最开始只有 (0, 0) 在畅通路径上，所以 dist[0][0] = 0 ，
//      并将 (0, 0) 加入队列 q 中。
//
//      当 q 不为空时，从队列中取出一个单元格 (r, c) ，
//      分别计算其 8 个方向上的相邻单元格 (rr, cc) 。
//
//      如果 (rr, cc) 合法 且 对应单元格为 0 且 未访问过，
//      则将 dist[rr][cc] 更新为 dist[r][c] + 1 ，
//      并将 (rr, cc) 加入队列 q 中。
//
//      最后 dist[n - 1][n - 1] 即为最短畅通路径，
//      如果 (n - 1, n - 1) 不可达，
//      那么 dist[n - 1][n - 1] 为 -1
//
//
//      时间复杂度：O(n ^ 2)
//          1. 需要初始化矩阵 dist 中的全部 O(n ^ 2) 个元素
//          2. 最差情况下，需要遍历全部 O(n ^ 2) 个单元格
//      空间复杂度：O(n ^ 2)
//          1. 需要维护一个队列 q 存储待访问的单元格，
//              最差情况下需要放入全部 O(n ^ 2) 的单元格
//          2. 需要维护一个大小为 O(n ^ 2) 的矩阵 dist ，
//              用于记录左上角到每个单元格的最短路径


// 8 个方向的位置改变量
var dr = []int{-1, -1, 0, 1, 1, 1, 0, -1};
var dc = []int{0, 1, 1, 1, 0, -1, -1, -1};


func shortestPathBinaryMatrix(grid [][]int) int {
    n := len(grid)
    // 起止点如果有一个不是 0 ，那么不存在畅通路径，直接返回 -1
    if grid[0][0] != 0 || grid[n - 1][n - 1] != 0 {
        return -1
    }
    // dist[r][c] 表示从左上角到 (r, c) 的最短畅通路径，
    // 初始化为 -1 ，表示不可达
    dist := make([][]int, n)
    for i := 0; i < n; i++ {
        dist[i] = make([]int, n)
        for j := 0; j < n; j++ {
            dist[i][j] = -1
        }
    }
    // 最开始只有 (0, 0) 在最短畅通路径中，距离为 1
    dist[0][0] = 1
    // 初始化一个队列 q ，存储待访问的单元格
    var q []*Pair
    // 最开始只有 (0, 0) 在待访问队列中
    q = append(q, &Pair{0, 0})
    for len(q) > 0 {
        // 获取队首单元格的下标
        cur := q[0]
        q = q[1:]
        r, c := cur.r, cur.c
        // 遍历 8 个方向的偏移量
        for i := 0; i < 8; i++ {
            // 计算相邻单元格的下标
            rr := r + dr[i]
            cc := c + dc[i]
            // 如果 (rr, cc) 合法 且 对应单元格为 0 且 未访问过
            if 0 <= rr && rr < n && 
                0 <= cc && cc < n && 
                grid[rr][cc] == 0 && 
                dist[rr][cc] == -1 {
                    // 更新 dist[rr][cc] 为 dist[r][c] + 1
                    dist[rr][cc] = dist[r][c] + 1
                    // 将 (rr, cc) 加入队列中
                    q = append(q, &Pair{rr, cc})
            }
        }
    }

    // dist[n - 1][n - 1] 即为最短畅通路径，
    // 如果 (n - 1, n - 1) 不可达，
    // 那么 dist[n - 1][n - 1] 为 -1
    return dist[n - 1][n - 1]
}

type Pair struct {
    r, c int
}