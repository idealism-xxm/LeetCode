// 链接：https://leetcode.com/problems/decode-ways/
// 题意：有一串大写字母，每一个字母被转换成数字（A -> 1, B -> 2, ..., Z -> 26）
//		将这些数字按照原有顺序再拼成数字串，现已知这个数字串，求远串有多少种可能？

// 输入："12"
// 输出：2
// 解释："AB" (1 2) or "L" (12)

// 输入："226"
// 输出：3
// 解释："BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6)

// 思路：DP
//		这种清状态简单的题目还是能够立刻想到 DP 的
//		类似 0070 这道题目
//		（原本以为很简单，但是数据不一定是合法的，且有未考虑到的例外情况，所以 WA 了几次）
//
//		设 dp[i] 表示以前 i 个字符对应的原串的可能数量
//		初始化：
//			dp[0] = 1 （空串）
//			1. s[0] == 0 -> dp[1] = 0  // s[0] 无法对应任何个一个字母
//			2. s[0] != 0 -> dp[1] = 1  // s[0] 唯一对应一个字母
//
//		dp[i] 可有两种状态转移而来：
//			1. s[i - 1] != '0' ，则 s[i - 1] 对应一个字母：
//				dp[i] += dp[i - 1]
//			2. s[i - 2] != '0' && s[i-2:i] <= "26"，则 s[i - 2] 和 s[i - 1] 合起来对应一个字母：
//				dp[i] += dp[i - 2]
//
// 		时间复杂度： O(n)

func numDecodings(s string) int {
	length := len(s)
	if length == 0 || s[0] == '0' {  // 特例：前导
		return 0
	}
	dp := make([]int, length + 1)
	dp[0] = 1
	if s[0] != '0' {  // 如果第一个字符是 0 ， s[0] 无法对应任何个一个字母
		dp[1] = 1
	}

	for i := 2; i <= length; i++ {
		if s[i - 1] != '0' {  // 不能含前导零
			// s[i - 1] 必定可以对应一个字母
			dp[i] = dp[i - 1]
		}

		num := (s[i - 2] - '0') * 10 + (s[i - 1] - '0')
		if s[i - 2] != '0' && num <= 26 {  // 不能含有前导零，且能组成字母
			// s[i - 2] 和 s[i - 1] 合起来对应一个字母
			dp[i] += dp[i - 2]
		}
	}
	return dp[length]
}
