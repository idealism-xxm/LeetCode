// 链接：https://leetcode.com/problems/unique-binary-search-trees/
// 题意：给定一个整数，求有多少种二叉搜索树？

// 输入：3
// 输出：5

// 思路：DP
//		上一题的简化版，只用求个数，少了遍历子树的部分
//
//		其实最开始就可以想到递归处理，
//		但是一想递归其实就是枚举该结点的的值，
//		然后将小于的值递归处理成左子树，再将大于的值递归处理成右子树
//		考虑到每次都是 x 个不同的树组成二叉搜索树，可以将 1~x 组成的所有结果存起来，
//		然后按照大小依次克隆，赋值为对应次序的值即可
//		这样以来就有子结构和递推方式了，很容易就可以转换为 DP
//
//		dp[i] 表示 1～i 个数可以构成的所有二叉搜索树
//		初始化：dp[0] = 1 （没有任何数字，即为 nil 结点）
//		状态转移方程：
//			对于 dp[i] 的根结点 j (1 <= j <= i) ，
//			其左子树有 dp[j - 1] 种，
//			其右子树有 dp[i - j - 1] 种
//			则：dp[i] += dp[j - 1] * dp[i - j - 1]
//		时间复杂度： O(n ^ 2)

func numTrees(n int) int {
	// 0 应该返回 0
	if n == 0 {
		return 0
	}

	dp := make([]int, n + 1)
	// 初始化 dp[0] = 1 （没有任何数字，即为 nil 结点）
	dp[0] = 1
	for i := 1; i <= n; i++ {
		// 枚举根结点的数字
		for j := 1; j <= i; j++ {
			// 左子树数量 * 右子树数量
			dp[i] += dp[j - 1] * dp[i - j]
		}
	}
	return dp[n]
}
