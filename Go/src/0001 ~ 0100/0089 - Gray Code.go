// 链接：https://leetcode.com/problems/gray-code/
// 题意：给定一个非负整数 n ，返回包含 0 ~ 2^n-1 的数组，
//		且满足任意两个相邻数的二进制表示下 1 的个数相差为 1 ？

// 输入：2
// 输出：[0,1,3,2] or [0,2,3,1]

// 输入：0
// 输出：[0]

// 思路1：DP
//		其实自己想到一个贪心的解法，不过实现起来过于麻烦，就放弃了
//		想法大致：从 0 开始，每次贪心取 1 的个数大于当前数的第一个数，
//				若没有，则取 1 的个数小于当前数的第一个数，
//				可以维护一个数组，表示 num[i] 表示有 i 个 1 的数下一个可使用的数字，
//				每次使用后更新的复杂度是 O(logn)
//		证明应该可从杨辉三角考虑
//
//		设 dp[i][j] 表示 n = i 时，对应的第 j 个数字
//		初始化：dp[0][0] = 0
//		状态转移：
//			1. 对 dp[i - 1] 数组的 2^(i - 1) 的每个数字前都加上 bit 0 ，即数字不变，
//				可得 n = i 时的前一半数字，即：
//				当 0 <= j < 2^(i - 1) 时： dp[i][j] = dp[i - 1][j]
//			2. 由于需要保证相邻数的二进制表示下 1 的个数相差为 1 ，
//				就要先保证 dp[i][2^(i - 1) - 1] 和 dp[i][2^(i - 1)] 满足题意，
//				刚好本层后半部分需要对对上一层最后一个数添加了 bit 1 ，放入刚好满足题意，
//				且它为上一次的最右端，所以可以将上一次翻转后，对每个数字前都加上 bit 1 ，得到新数字，即：
//				当 2^(i - 1) <= j < 2^i 时： dp[i][j] = dp[i - 1][2^i - 1 - j] | (1 << (i - 1))
//		由于每次状态转移时前一半都不需要改变，所以可以只用一维数组即可，还能降低时间复杂度
//		时间复杂度： O(2^n)

func grayCode(n int) []int {
	dp := make([]int, 1 << n)
	dp[0] = 0
	for i := 1; i <= n; i++ {
		for j := 1 << (i - 1); j < (1 << i); j++ {
			dp[j] = dp[(1 << i) - 1 - j] | (1 << (i - 1))
		}
	}
	return dp
}

// 思路2：数学
//		格雷码有数学公式可以直接通过二进制转换得到：
//		G(i) = B(i >> 1) xor B(i)
//		其中： G(i) 表示第 i 个格雷码，B(i) 表示 i 二进制数
//
//		时间复杂度： O(2^n)

func grayCode(n int) []int {
	result := make([]int, 1 << n)
	for i := 0; i < (1 << n); i++ {
		result[i] = (i >> 1) ^ i
	}
	return result
}
