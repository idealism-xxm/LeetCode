// 链接：https://leetcode.com/problems/count-vowels-permutation/
// 题意：计算满足以下条件的长度为 n 的字符串个数：
//          1. 字符串中的字母必须是全部是小写的元音字母
//          2. 'a' 后面只能跟 'e'
//          3. 'e' 后面只能跟 'a', 'i'
//          4. 'i' 后面只能跟 'a', 'e', 'o', 'u'
//          5. 'o' 后面只能跟 'i', 'u'
//          6. 'u' 后面只能跟 'a'


// 数据限制：
//  1 <= n <= 2 * 10 ^ 4


// 输入： n = 1
// 输出： 5
// 解释： 所有可能的字符串分别是： "a", "e", "i", "o", "u" 。

// 输入： n = 2
// 输出： 10
// 解释： 所有可能的字符串分别是： "ae", "ea", "ei", "ia", "ie", 
//                            "io", "iu", "oi", "ou", "ua"

// 输入： n = 5
// 输出： 68


// 思路： DP
//
//      为了方便处理，我们将元音 'a', 'e', 'i', 'o', 'u' 分别用 0, 1, 2, 3, 4 表示。
//
//      那么，我们就可以将题目的限制条件转换为转移数组 NextVowel ，
//      其中 NextVowel[i] 表示第 i 个元音字母后面能跟的元音字母列表。
//          1. NextVowel[0] = [1]           // 'a' 后面只能跟 'e'
//          2. NextVowel[1] = [0, 2]        // 'e' 后面只能跟 'a', 'i'
//          3. NextVowel[2] = [0, 1, 3, 4]  // 'i' 后面只能跟 'a', 'e', 'o', 'u'
//          4. NextVowel[3] = [2, 4]        // 'o' 后面只能跟 'i', 'u'
//          5. NextVowel[4] = [0]           // 'u' 后面只能跟 'a'
//
//      设 dp[i][j] 表示长度为 i 的字符串中，
//      最后一个字母是第 j 个元音 且 满足题意的字符串的个数。
//
//      初始化： dp[i][j] = 0; dp[1][j] = 1 。
//          初始时，只确定长度为 1 的元音字符串满足题意。
//
//      状态转移：对于已确定的状态 dp[i][j] ，我们知道这些字符串后面能放的字母列表为 NextVowel[j] ，
//          对于 NextVowel[j] 中的每个字母 k ，我们可以将状态 dp[i][j] 转移至 dp[i + 1][k] ，
//          即 dp[i + 1][k] = dp[i + 1][k] + dp[i][j]
//
//      最后求和a所有满足题意的长度为 n 的字符串个数，即 sum(dp[n]) 。
//
//
//      DP 常见的三种优化方式见 LeetCode 583 这题的思路，
//      本题可以采用滚动数组的方式进行优化，因为每一行的状态依赖上一行的所有状态，
//      所以无法采用其他两种方式进行优化。
//
//      使用滚动数组的话，能将空间复杂度从 O(nC) 优化为 O(C) ，
//      本实现为了便于理解，不做优化处理。
//
//
//      进阶优化：使用矩阵快速幂处理，可以将时间复杂度优化为 (logn * C ^ 3) 。
//
//
//      设元音个数为 C = 5 。
//
//      时间复杂度：O(nC)
//          1. 需要遍历全部 O(nC) 个状态
//      空间复杂度：O(nC)
//          1. 需要维护 dp 的全部 O(nC) 个状态


const MOD int = 1_000_000_007
// NextVowel[i] 表示第 i 个元音字母后面能跟的元音字母列表
var NextVowel [][]int = [][]int{
    []int{1},            // 'a' 后面只能跟 'e'
    []int{0, 2},         // 'e' 后面只能跟 'a', 'i'
    []int{0, 1, 3, 4},   // 'i' 后面只能跟 'a', 'e', 'o', 'u'
    []int{2, 4},         // 'o' 后面只能跟 'i', 'u'
    []int{0},            // 'u' 后面只能跟 'a'
}


func countVowelPermutation(n int) int {
    // dp[i][j] 表示长度为 i 的字符串中，
    // 最后一个字母是第 j 个元音 且 满足题意的字符串的个数
    dp := make([][]int, n + 1)
    // 初始化长度为 1 的元音字符串必定满足题意
    dp[1] = []int{1, 1, 1, 1, 1}
    for i := 1; i < n; i++ {
        dp[i + 1] = make([]int, 5)
        // 枚举长度为 i 的字符串最后一个字母为第 j 个元音的情况
        for j := range dp[i] {
            // 遍历第 j 个元音字母后面能跟的元音字母 k
            for _, k := range NextVowel[j] {
                // 将 dp[i][j] 的状态转移至 dp[i + 1][k]
                dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD
            }
        }
    }

    // 求和所有满足题意的长度为 n 的字符串个数
    ans := 0
    for _, count := range dp[n] {
        ans = (ans + count) % MOD
    }
    return ans
}
