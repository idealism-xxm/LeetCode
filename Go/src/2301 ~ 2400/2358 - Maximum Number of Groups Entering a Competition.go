// 链接：https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
// 题意：给定一个正整数数组 grades ，表示学生的分数。
//      现在需要将这些学生分成非空的组，且需要满足以下条件：
//          1. 第 i 组学生的分数和小于第 i + 1 组学生的分数和
//          2. 第 i 组学生的人数小于第 i + 1 组学生的人数
//
//      求最多能分成多少组？


// 数据限制：
//  1 <= grades.length <= 10 ^ 5
//  1 <= grades[i] <= 10 ^ 5


// 输入： grades = [10,6,12,7,3,5]
// 输出： 3
// 解释： 第 1 组学生的分数为 [12] ，分数和为 12 ，人数为 1 ；
//       第 2 组学生的分数为 [6,7] ，分数和为 13 ，人数为 2 ；
//       第 3 组学生的分数为 [10,3,5] ，分数和为 18 ，人数为 3 。

// 输入： grades = [8,8]
// 输出： 1
// 解释： 只能分成一组。因为如果分成两组的话，那么两组的人数相同，不满足题意。


// 思路： 贪心 + 数学
//
//      为了使得分组最多，我们必定要贪心地给人数最少的第 1 组分 1 个人，
//      后续分组只比前一个分组多 1 个人。
//
//      如果这样分到最后，剩余的人无法再比前一个分组多 1 个人，则都并入最后一个分组。
//
//      这样我们就满足了题目的第二个条件，然后我们需要想办法给每个分组选择对应的人，
//      使得每个分组都满足题目的第一个条件。
//
//      由于分组的人数是递增的，即使所有人分数一样，分组的分数和也必定是递增的。
//
//      那么缩放一下就知道：如果将分数小的人放在人数少的组（即分数最小的人给第 1 组，
//      接下来最小的 2 个人给第 2 组，以此类推），那么相邻组的分数和之差必定会扩大，
//      依旧满足题意。
//
//      如果按照这种思路模拟，那么必定是先对 grades 按升序排序，
//      然后给第 i 组分接下来的 i 个人，直至剩余的人数不大于第 k 组的人数，
//      那么结果就是最多能分 k 组。
//
//      由于本题不关心每一组具体的人，只关心最多有多少组，
//      所以我们可以直接二分第 k 组，并求其人数和 k * (k + 1) / 2 ，
//      找到满足 k * (k + 1) / 2 <= n 的最大 k ，则其为最大分组数。
//
//      这样的时间复杂度为 O(logn) ，因为二分时间复杂度为 O(logn) 。
//
//      但我们可以运用数学公式直接在 O(1) 内计算出最终的结果，对刚刚的不等式变形：
//          k * (k + 1) / 2 <= n
//      →   k ^ 2 + k <= 2n
//      →   k ^ 2 + k + 1/4 <= 2n + 1/4
//      →   (k + 1/2) ^ 2 <= 2n + 1/4
//      →   k + 1/2 <= sqrt(2n + 1/4)
//      →   k <= sqrt(2n + 1/4) - 1/2
//      →   k <= sqrt(2n + 0.25) - 0.5
//
//      那么 k 的最大值为 floor(sqrt(2n + 0.25) - 0.5) 。
//
//
//      时间复杂度：O(1)
//          1. 根据数学公式直接计算即可，假设内置的 sqrt 函数的时间复杂度为 O(1)
//      空间复杂度：O(1)
//          1. 只需要使用常数个额外变量


import "math"


func maximumGroups(grades []int) int {
    n := float64(len(grades))
    return int(math.Sqrt(2.0 * n + 0.25) - 0.5)
}
