// 链接：https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/
// 题意：给定一个字符串 s ，找到大小写都出现过的所有字母中，最大的那个字母。
//       如果存在，则返回大写字母对应的字符串，否则返回空串。


// 数据限制：
//  1 <= s.length <= 1000
//  s 仅有英文大小写字母组成


// 输入： s = "lEeTcOdE"
// 输出： "E"
// 解释： 只有字母 'E' 的大小写都出现过。

// 输入： s = "arRAzFif"
// 输出： "R"
// 解释： 字母 'A', 'F' 和 'R' 的大小写都出现过，最大的字母是 'R' 。

// 输入： s = "AbCdEfGhIjK"
// 输出： ""
// 解释： 没有字母大小写都出现过。


// 思路： 位运算
//
//      按照题目模拟即可，可以使用位运算方便处理。
//
//      设 mask[i] 表示第 i 个字母大小写出现的情况：
//          1. mask[i] & 1 表示第 i 个小写字母的出现情况
//          2. mask[i] & 2 表示第 i 个大写字母的出现情况
//      对应位为 0 表示未出现，为 1 表示已出现。
//
//      如果第 i 个字母大小写都出现过，则必有 mask[i] == 1 | 2 == 3 。
//
//      可以先遍历 s 统计第 i 个字母的大小写出现情况，然后倒着找到第一个大小写出现的字母并返回。
//      如果最后没找到，则不存在这样的字母，直接返回空串。
//
//
//      设字符集大小为 C 。
//
//      时间复杂度：O(n + C)
//          1. 需要遍历 s 中全部 O(n) 个字母
//          2. 需要遍历全部 O(C) 种字母
//               (1) 可以在遍历 s 时，顺便求满足题意的结果，能优化掉这部分的时间复杂度，但代码可读性会变差，没必要这样处理
//      空间复杂度：O(C)
//          1. 需要使用 mask 维护全部 O(C) 个状态



func greatestLetter(s string) string {
    // mask[i] & 1 表示第 i 个小写字母的出现情况，
    // mask[i] & 2 表示第 i 个大写字母的出现情况，
    // 对应位为 0 表示未出现，为 1 表示已出现。
    mask := make([]int, 26)
    // 统计 s 中全部字母的出现情况
    for _, ch := range s {
        if 'a' <= ch && ch <= 'z' {
            mask[ch - 'a'] |= 1
        } else {
            mask[ch - 'A'] |= 2
        }
    }
    // 倒着找到第一个大小写都出现过的字母，返回其大写字母对应的字符串
    for i := 25; i >= 0; i-- {
        // 如果第 i 个字母大小写都出现过，则必有 mask[i] == 1 | 2 == 3
        if mask[i] == 3 {
            return fmt.Sprintf("%c", i + 'A')
        }
    }

    // 此时必定没有大小写都出现过的字母，返回空串
    return ""
}
