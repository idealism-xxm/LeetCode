// 链接：https://leetcode.com/problems/triangle/
// 题意：给定一个数组 triangle ，求从顶部到底部的路径中数字和的最小值。
//
//      如果当前在第 i 列，那么可以选择到达下一行的第 i 列或第 i + 1 列。
//
//      进阶：使用空间复杂度为 O(n) 的算法求解。


// 数据限制：
//  1 <= triangle.length <= 200
//  triangle[0].length == 1
//  triangle[i].length == triangle[i - 1].length + 1
//  -(10 ^ 4) <= triangle[i][j] <= 10 ^ 4


// 输入： triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
// 输出： 11
// 解释： 数字和最小的路径是 2 -> 3 -> 5 -> 1 ，数字和为 11 。
//       (2)
//       (3) 4
//        6 (5) 7
//        4 (1) 8 3

// 输入： triangle = [[-10]]
// 输出： -10


// 思路1： DP
//
//      DP 入门题，定义 dp[i][j] 表示走到第 i 行第 j 列时数字和的最小值。
//
//      初始化： dp[0][0] = triangle[0][0]
//      状态转移：只有 (i - 1, j - 1) 和 (i - 1, j) 能走到 (i, j) ，
//          所以 dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j]
//
//      那么满足题意的答案就是 min(dp[n - 1]) 。
//
//      这个方法的空间复杂度是 O(n ^ 2) 的，不满足进阶的要求，
//      我们看看未注意的关键点，从这些方面来优化突破：
//          1. 状态转移时，只会通过上一行的状态 dp[i - 1] 来更新当前行的状态 dp[i] ，
//              而最终结果会从最后一行的状态 dp[n - 1] 中得到。
//              那么我们只需要维护当前行和上一行这两行的状态即可，
//              使用滚动数组就能优化为 O(n) 的空间复杂度。
//          2. 状态转移时， dp[i][j] 可由 dp[i - 1][j - 1] 和 dp[i - 1][j] 转移。
//              如果只使用一维数组，那么 dp[j] 的状态可由 dp[j] 和 dp[j - 1] 转移，
//              因为每个位置只能走一次，所以在更新 dp[j] 时，要保证 dp[j - 1] 是上一行的状态，
//              那么只要我们从大到小更新 dp[j] 即可。
//
//      这两个优化都是背包常见的优化方法，最终能将空间复杂度优化为 O(n) ，且只使用一个一维数组。
//
//
//      时间复杂度：O(n ^ 2)
//          1. 需要遍历全部 O(n ^ 2) 个状态
//      空间复杂度：O(n)
//          1. 需用维护 dp 中一行的 O(n) 个状态


func minimumTotal(triangle [][]int) int {
	// 定义 dp 数组，为了方便后续处理，初始化为一个极大值 0x3f3f3f3f
	dp := make([]int, len(triangle))
	for i := range dp {
		dp[i] = 0x3f3f3f3f
	}
	// 初始化第一行的状态
	dp[0] = triangle[0][0]
	// 将第 i - 1 行的状态转移至第 i 行
	for i := 1; i < len(triangle); i++ {
		// 每一行从大到小更新 dp[j] ，保证 dp[j - 1] 是上一行的状态
		for j := i; j > 0; j-- {
			dp[j] = min(dp[j], dp[j - 1]) + triangle[i][j]
		}
		// dp[0] 只能从 dp[0] 转移而来，所以直接加上 triangle[i][0]
		dp[0] += triangle[i][0]
	}

	// 最后一行的状态的最小值就是答案
	return min(dp...)
}

func min(nums ...int) int {
	ans := nums[0];
	for _, num := range nums {
		if num < ans {
			ans = num
		}
	}
	return ans
}


// 思路2：DP
//
//		思路 1 中的做法是按照题目从顶到底进行状态转移，但这样会修改转移关系，
//		不容易想清楚，并且需要用一个极大值初始化，用以保证状态转移的正确性。
//
//		其实我们可以从底到顶进行状态转移（相当于将从上到下的有向边反转），
//		这样就不需要进行各种特殊处理，状态转移方程非常简单，
//		并且最终结果就是 dp[0] ，无需再求一遍最大值。
//
//		设 dp[j] 表示当前从底部转移到当前层第 j 列时数字和的最小值。
//
//		初始化： dp[1~n] = 0 。为了方便处理底部的一行，令 dp 的长度为 n + 1
//		状态转移： 只有 (i + 1, j) 和 (i + 1, j + 1) 能走到 (i, j) ，
//			dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
//
//		那么满足题意的答案就是 dp[0] 。
//
//
//      时间复杂度：O(n ^ 2)
//          1. 需要遍历全部 O(n ^ 2) 个状态
//      空间复杂度：O(n)
//          1. 需用维护 dp 中一行的 O(n) 个状态


func minimumTotal(triangle [][]int) int {
	// dp[j] 表示当前从底部转移到当前层第 j 列时数字和的最小值，
	// 初始全为 0 ，为了方便处理底部的一行，令 dp 的长度为 n + 1
	dp := make([]int, len(triangle) + 1)
	// 从底部到顶部进行状态转移
	for i := len(triangle) - 1; i >= 0; i-- {
		// 每一行从小到大更新 dp[j] ，保证 dp[j + 1] 是下一行的状态
		for j := 0; j <= i; j++ {
			// 只有 (i + 1, j) 和 (i + 1, j + 1) 能走到 (i, j)
			dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
		}
	}
	return dp[0]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
