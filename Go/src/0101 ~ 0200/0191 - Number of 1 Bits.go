// 链接：https://leetcode.com/problems/number-of-1-bits/
// 题意：给定一个 32 位无符号整数，统计其二进制下 1 的数量？

// 输入： 00000000000000000000000000001011
// 输出： 3

// 输入： 00000000000000000000000010000000
// 输出： 1

// 输入： 11111111111111111111111111111101
// 输出： 31

// 思路： 位运算
//
//		可以直接判断每一位上的数字，若是 1 则加在结果里即可
//
//		看了题解后，一直在大脑里呼之欲出的解法终于又知道了，
//		运用位运算 n & (n - 1) 可以去除 n 最后一个 1
//		假设当前数字 （为了方便，只展示 8 位） n = 01011100
//		那么： n - 1 = 01011011 ，
//		可以发现 n 和 n - 1 从 n 最后一个 1 开始都是相反的，
//		所以可以使用 n & (n - 1) 去除 n 最后一个 1
//		这样每次只会循环二进制中 1 的数量，最多为 32
//
//		时间复杂度： O(1)
//		空间复杂度： O(1)

func hammingWeight(num uint32) int {
	count := 0
	for num > 0 {
		count++
		num &= num - 1
	}
	return count
}
