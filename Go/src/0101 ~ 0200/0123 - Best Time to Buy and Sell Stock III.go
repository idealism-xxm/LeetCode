// 链接：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
// 题意：给定一只股票连续几天的价格，求最多只买卖一次的情况下最大获利？

// 输入： [3,3,5,0,0,3,1,4]
// 输出： 6
// 解释： 第四天买 (price = 0) ，第六天卖 (price = 3) ，获利 3
//		 第七天买 (price = 1) ，第八天卖 (price = 3) ，获利 3
//		 总共进行 2 次买卖，共获利 6

// 输入： [1,2,3,4,5]
// 输出： 4
// 解释： 第一天买 (price = 1) ，第五天卖 (price = 5) ，获利 4
//		 总共进行 1 次买卖，共获利 4

// 输入： [7,6,4,3,1]
// 输出： 0
// 解释： 不做任何买卖，获利 0

// 思路： DP
//		感觉思维被 0122 的思路 1 固化了，导致自己即使知道存在 O(n) 的 DP 也很难想出来，
//		最终还是看了题解才发现用状态机的思想去表示状态
//
//		设 dp[i][j] 表示 prices[:i] 经过交易后在状态 j 时的最大资产
//			j = 0: 未进行任何交易
//			j = 1: 已买入第一支股票
//			j = 2: 已卖出第一只股票
//			j = 3: 已买入第二支股票
//			j = 4: 已卖出第二支股票
//		最终答案为： max(dp[n][0], dp[n][2], dp[n][4])
//
//		初始化： dp[0][0] = 0 （未进行交易，最大资产为 0）
//		状态转移：
//			1. 当天不做交易，则未进行任何交易的状态不会改变，直接用前一天相同状态的资产即可（其实这个值一直都是 0）
//			dp[i][0] = dp[i - 1][0]
//			2. 当天不做交易时，为前一天相同状态的资产；当天买入第一支股票，则从前一天未进行任何交易状态转移
//			dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])
//			3. 当天不做交易时，为前一天相同状态的资产；当天卖出第一支股票，则从前一天买入第一支股票状态转移
//			dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i - 1])
//			4. 当天不做交易时，为前一天相同状态的资产；当天买入第一支股票，则从前一天卖出第一支股票状态转移
//			dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i - 1])
//			5. 当天不做交易时，为前一天相同状态的资产；当天买入第一支股票，则从前一天买入第二支股票状态转移
//			dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i - 1])
//
//		由于状态转移时只会用到它上边和左上的数据，所以可以优化为 O(1) ，直接用 dp[5]，从后往前更新即可
//		（本题不改变顺序也行，因为此时从前往后相当于今天可能进行了两次操作，
//		但这不影响，因为这样无任何盈利，还会减少可交易的次数）
//
//		时间复杂度： O(n)
//		空间复杂度： O(1)


func maxProfit(prices []int) int {
	length := len(prices)
	// 如果不够两天，必定无利润
	if length < 2 {
		return 0
	}

	dp := make([]int, 5)
	// 设为一个不可能达到的最小值，方便简化后续逻辑（如果不支持，则只能对每一位标记是否合法）
	for i := 1; i < 5; i++ {
		dp[i] = math.MinInt32
	}
	for i := 0; i < length; i++ {
		// 当天不做交易时，为前一天相同状态的资产；当天买入第一支股票，则从前一天买入第二支股票状态转移
		dp[4] = max(dp[4], dp[3] + prices[i])
		// 当天不做交易时，为前一天相同状态的资产；当天买入第一支股票，则从前一天卖出第一支股票状态转移
		dp[3] = max(dp[3], dp[2] - prices[i])
		// 当天不做交易时，为前一天相同状态的资产；当天卖出第一支股票，则从前一天买入第一支股票状态转移
		dp[2] = max(dp[2], dp[1] + prices[i])
		// 当天不做交易时，为前一天相同状态的资产；当天买入第一支股票，则从前一天未进行任何交易状态转移
		dp[1] = max(dp[1], dp[0] - prices[i])
		// 当天不做交易，则未进行任何交易的状态不会改变，直接用前一天相同状态的资产即可
	}
	return max(dp[0], max(dp[2], dp[4]))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
