// 链接：https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
// 题意：给定一个非负数 num ，执行多少次以下操作后会变成 0 ？
//      可以执行的操作有两种：
//          1. num 是奇数时， num 减去 1
//          2. num 是偶数时， num 除以 2


// 数据限制：
//  0 <= num <= 10 ^ 6


// 输入： num = 14
// 输出： 6
// 解释： (1) 14 是偶数，除以 2 得到 7 。
//       (2)  7 是奇数，减去 1 得到 6 。
//       (3)  6 是偶数，除以 2 得到 3 。
//       (4)  3 是奇数，减去 1 得到 2 。
//       (5)  2 是偶数，除以 2 得到 1 。
//       (6)  1 是奇数，减去 1 得到 0 。

// 输入： num = 8
// 输出： 4
// 解释： (1) 8 是偶数，除以 2 得到 4 。
//       (2) 4 是偶数，除以 2 得到 2 。
//       (3) 2 是偶数，除以 2 得到 1 。
//       (4) 1 是奇数，减去 1 得到 0 。

// 输入： num = 123
// 输出： 12


// 思路： 位运算
//
//      按照题意模拟即可，统计需要执行的操作数，直至 num 变为 0 。
//
//      每次循环时，进行如下处理：
//          1. 先判断 num 是否为奇数，如果 num & 1 == 1 ，
//              则要先执行并统计减法操作： num -= 1; ans += 1; 
//          2. 此时 num 必定是偶数，如果 num > 0 ，
//              则需要执行并统计除法操作： num /= 2; ans += 1;
//
//      最后 ans 就是所需的操作次数。
//
//      可以发现：
//          1. 统计减法操作可以直接用 num & 1 处理，
//              就不需要判断 num 是否为奇数了。
//          2. 除法操作除了 num 为 1 时，必定执行，那么也可以每次都执行除法操作，
//              在返回时减去多计算的最后一次除法操作即可。
//
//      这样优化后，就无需再循环内多次判断，可以直接使用位运算处理，
//      充分利用 CPU 的流水线，减少分支预测失败的性能损耗。
//
//
//      设 n 为 num 。
//
//      时间复杂度：O(logn)
//          1. 需要对 num 执行 O(logn) 次除法操作，将其变为 0
//      空间复杂度：O(1)
//          1. 只需要维护常数个额外变量即可


func numberOfSteps(num int) int {
    // 如果 num 为 0 ，则无需任何操作
    if num == 0 {
        return 0
    }

    // ans 维护需要操作的次数
    ans := 0
    // 当 num > 0 时，需要继续操作
    for num > 0 {
        // 1. num 如果是奇数，则要先执行减 1 ，
        //      可以用 num & 1 来表示是否执行了减 1 操作
        // 2. 判断执行完减法操作后，此时 num 会变为偶数，
        //      必定需要执行一次除以 2 的操作
        ans += (num & 1) + 1
        // num 右移一位，必定执行除以 2 的操作，
        // 如果最后一位是 1 ，则也先执行了减 1 的操作
        num >>= 1
    }

    // 由于最后必定是 1 变为 0 ，所以多统计了一次对 0 除以 2 的操作
    return ans - 1
}
