// 链接：https://leetcode.com/problems/count-vowels-permutation/
// 题意：计算满足以下条件的长度为 n 的字符串个数：
//          1. 字符串中的字母必须是全部是小写的元音字母
//          2. 'a' 后面只能跟 'e'
//          3. 'e' 后面只能跟 'a', 'i'
//          4. 'i' 后面只能跟 'a', 'e', 'o', 'u'
//          5. 'o' 后面只能跟 'i', 'u'
//          6. 'u' 后面只能跟 'a'


// 数据限制：
//  1 <= n <= 2 * 10 ^ 4


// 输入： n = 1
// 输出： 5
// 解释： 所有可能的字符串分别是： "a", "e", "i", "o", "u" 。

// 输入： n = 2
// 输出： 10
// 解释： 所有可能的字符串分别是： "ae", "ea", "ei", "ia", "ie", 
//                            "io", "iu", "oi", "ou", "ua"

// 输入： n = 5
// 输出： 68


// 思路： DP
//
//      为了方便处理，我们将元音 'a', 'e', 'i', 'o', 'u' 分别用 0, 1, 2, 3, 4 表示。
//
//      那么，我们就可以将题目的限制条件转换为转移数组 next_vowel ，
//      其中 next_vowel[i] 表示第 i 个元音字母后面能跟的元音字母列表。
//          1. next_vowel[0] = [1]           // 'a' 后面只能跟 'e'
//          2. next_vowel[1] = [0, 2]        // 'e' 后面只能跟 'a', 'i'
//          3. next_vowel[2] = [0, 1, 3, 4]  // 'i' 后面只能跟 'a', 'e', 'o', 'u'
//          4. next_vowel[3] = [2, 4]        // 'o' 后面只能跟 'i', 'u'
//          5. next_vowel[4] = [0]           // 'u' 后面只能跟 'a'
//
//      设 dp[i][j] 表示长度为 i 的字符串中，
//      最后一个字母是第 j 个元音 且 满足题意的字符串的个数。
//
//      初始化： dp[i][j] = 0; dp[1][j] = 1 。
//          初始时，只确定长度为 1 的元音字符串满足题意。
//
//      状态转移：对于已确定的状态 dp[i][j] ，我们知道这些字符串后面能放的字母列表为 next_vowel[j] ，
//          对于 next_vowel[j] 中的每个字母 k ，我们可以将状态 dp[i][j] 转移至 dp[i + 1][k] ，
//          即 dp[i + 1][k] = dp[i + 1][k] + dp[i][j]
//
//      最后求和a所有满足题意的长度为 n 的字符串个数，即 sum(dp[n]) 。
//
//
//      DP 常见的三种优化方式见 LeetCode 583 这题的思路，
//      本题可以采用滚动数组的方式进行优化，因为每一行的状态依赖上一行的所有状态，
//      所以无法采用其他两种方式进行优化。
//
//      使用滚动数组的话，能将空间复杂度从 O(nC) 优化为 O(C) ，
//      本实现为了便于理解，不做优化处理。
//
//
//      进阶优化：使用矩阵快速幂处理，可以将时间复杂度优化为 (logn * C ^ 3) 。
//
//
//      设元音个数为 C = 5 。
//
//      时间复杂度：O(nC)
//          1. 需要遍历全部 O(nC) 个状态
//      空间复杂度：O(nC)
//          1. 需要维护 dp 的全部 O(nC) 个状态


const MOD: i32 = 1_000_000_007;


impl Solution {
    pub fn count_vowel_permutation(n: i32) -> i32 {
        // next_vowel[i] 表示第 i 个元音字母后面能跟的元音字母列表
        let next_vowel: [Vec<usize>; 5] = [
            vec![1],            // 'a' 后面只能跟 'e'
            vec![0, 2],         // 'e' 后面只能跟 'a', 'i'
            vec![0, 1, 3, 4],   // 'i' 后面只能跟 'a', 'e', 'o', 'u'
            vec![2, 4],         // 'o' 后面只能跟 'i', 'u'
            vec![0],            // 'u' 后面只能跟 'a'
        ];

        let n = n as usize;
        // dp[i][j] 表示长度为 i 的字符串中，
        // 最后一个字母是第 j 个元音 且 满足题意的字符串的个数
        let mut dp = vec![vec![0; 5]; n + 1];
        // 初始化长度为 1 的元音字符串必定满足题意
        dp[1] = vec![1, 1, 1, 1, 1];
        for i in 1..n {
            // 枚举长度为 i 的字符串最后一个字母为第 j 个元音的情况
            for j in 0..5 {
                // 遍历第 j 个元音字母后面能跟的元音字母 k
                for &k in next_vowel[j].iter() {
                    // 将 dp[i][j] 的状态转移至 dp[i + 1][k]
                    dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD;
                }
            }
        }

        // 求和所有满足题意的长度为 n 的字符串个数
        dp[n].iter().fold(0, |sum, count| (sum + count) % MOD)
    }
}
