// 链接：https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/
// 题意：给定一个字符串 s ，找到大小写都出现过的所有字母中，最大的那个字母。
//       如果存在，则返回大写字母对应的字符串，否则返回空串。


// 数据限制：
//  1 <= s.length <= 1000
//  s 仅有英文大小写字母组成


// 输入： s = "lEeTcOdE"
// 输出： "E"
// 解释： 只有字母 'E' 的大小写都出现过。

// 输入： s = "arRAzFif"
// 输出： "R"
// 解释： 字母 'A', 'F' 和 'R' 的大小写都出现过，最大的字母是 'R' 。

// 输入： s = "AbCdEfGhIjK"
// 输出： ""
// 解释： 没有字母大小写都出现过。


// 思路： 位运算
//
//      按照题目模拟即可，可以使用位运算方便处理。
//
//      设 mask[i] 表示第 i 个字母大小写出现的情况：
//          1. mask[i] & 1 表示第 i 个小写字母的出现情况
//          2. mask[i] & 2 表示第 i 个大写字母的出现情况
//      对应位为 0 表示未出现，为 1 表示已出现。
//
//      如果第 i 个字母大小写都出现过，则必有 mask[i] == 1 | 2 == 3 。
//
//      可以先遍历 s 统计第 i 个字母的大小写出现情况，然后倒着找到第一个大小写出现的字母并返回。
//      如果最后没找到，则不存在这样的字母，直接返回空串。
//
//
//      设字符集大小为 C 。
//
//      时间复杂度：O(n + C)
//          1. 需要遍历 s 中全部 O(n) 个字母
//          2. 需要遍历全部 O(C) 种字母
//               (1) 可以在遍历 s 时，顺便求满足题意的结果，能优化掉这部分的时间复杂度，但代码可读性会变差，没必要这样处理
//      空间复杂度：O(C)
//          1. 需要使用 mask 维护全部 O(C) 个状态


impl Solution {
    pub fn greatest_letter(s: String) -> String {
        let s = s.as_bytes();
        // mask[i] & 1 表示第 i 个小写字母的出现情况，
        // mask[i] & 2 表示第 i 个大写字母的出现情况，
        // 对应位为 0 表示未出现，为 1 表示已出现。
        let mut mask = vec![0; 26];
        // 统计 s 中全部字母的出现情况
        for &ch in s {
            if b'a' <= ch && ch <= b'z' {
                mask[(ch - b'a') as usize] |= 1;
            } else {
                mask[(ch - b'A') as usize] |= 2;
            }
        }
        // 倒着找到第一个大小写都出现过的字母，返回其大写字母对应的字符串
        for i in (0..26).rev() {
            // 如果第 i 个字母大小写都出现过，则必有 mask[i] == 1 | 2 == 3
            if mask[i] == 3 {
                return String::from_utf8(vec![i as u8 + b'A']).unwrap();
            }
        }

        // 此时必定没有大小写都出现过的字母，返回空串
        "".to_string()
    }
}
