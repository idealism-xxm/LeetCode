// 链接：https://leetcode.com/problems/complement-of-base-10-integer/
// 题意：给定一个非负整数 n ，求其有效二进制的反码对应的十进制数？
//      （除 0 外，所有的有效二进制都不含有前导零）

// 数据限制：
//  0 <= N < 10 ^ 9

// 输入： 5
// 输出： 2
// 解释： 5 的二进制表示为 "101" ，
//         其二进制反码为 "010" ，也就是十进制中的 2

// 输入： 7
// 输出： 0
// 解释： 7 的二进制表示为 "111" ，
//         其二进制反码为 "000" ，也就是十进制中的 0

// 输入： 10
// 输出： 5
// 解释： 10 的二进制表示为 "1010" ，
//          其二进制反码为 "0101" ，也就是十进制中的 5


// 思路：位运算
//
//      当 n 等于 0 时，直接返回 1 即可。
//          因为 0 的二进制是 "0" ，
//          其二进制反码是 "1" ，对应十进制中的 1
//      当 n 大于 0 时，按照题意反转所有有效位即可，
//          也就是从最高为 1 的二进制位开始向低位全部按位取反
//          
//
//      时间复杂度： O(logn)
//      空间复杂度： O(1)

impl Solution {
    pub fn bitwise_complement(mut n: i32) -> i32 {
        // 当 n 是 0 时，必须得有一个二进制位，
        // 此时对这个二进制位取反的结果为 1
        if n == 0 {
            return 1;
        }

        let mut ans = 0;
        // bit 为从低到高的每一个为 1 的二进制位，
        // 初始化为 1 ，此时最低位为 1
        let mut bit = 1;
        // 当 n > 1 时，说明 n 目前还有没有处理二进制位的二进制位的 0 ，
        //  需要继续反转后续的二进制位
        // 当 n == 1 时，说明已经处理了所有有效的二进制位的 0 ，
        //  现在只剩一个最高为 1 ，对结果无影响，不用再继续处理了
        while n > 1 {
            // 如果当前 n 的最低位是 0 ，则需要反转成 1 ，
            // 反应到结果中就是 ans 对应的 bit 位要是 1 ，
            // 把 bit 按位或给 ans 即可
            if n & 1 == 0 {
                ans |= bit
            }
            // 此时要处理 ans 的高一位， bit 左移动一位即可
            bit <<= 1;
            // n 右移一位，方便后续判断，以及取还未处理的最低位
            n >>= 1;
        }
        // 返回结果
        ans
    }
}
