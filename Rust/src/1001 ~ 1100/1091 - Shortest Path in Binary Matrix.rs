// 链接：https://leetcode.com/problems/shortest-path-in-binary-matrix/
// 题意：给定一个 n * n 的矩阵 grid ，返回其中最短的畅通路径，如果不存在返回 -1 。
//
//      畅通路径满足一下条件：
//          1. 从左上角 (0, 0) 开始，到右下角 (n - 1, n - 1) 结束
//          2. 路径上的的所有单元格的值都是 0
//          3. 所有单元格都是 8 联通的（两个共享同一条边或同一个角的单元格是联通的）


// 数据限制：
//  n == grid.length
//  n == grid[i].length
//  1 <= n <= 100
//  grid[i][j] 是 0 或 1


// 输入： grid = [[0,1],[1,0]]
// 输出： 2
// 解释： (0)  1
//          ↘
//        1  (0)

// 输入： grid = [[0,0,0],[1,1,0],[1,1,0]]
// 输出： 4
// 解释： (0) → (0)  0
//                ↘
//        1     1  (0)
//                  ↓
//        1     1  (0)

// 输入： grid = [[1,0,0],[1,1,0],[1,1,0]]
// 输出： -1


// 思路： BFS
//
//      由于这个图是 8 联通的，各个状态之间不是严格有序的，即无法递推，
//      所以不能使用 DP 。
//
//      但这个图的边权都是 1 ，所以可以直接使用 BFS 找到最短路。
//
//      可以维护一个矩阵 dist ，
//      其中 dist[r][c] 表示从左上角到 (r, c) 的最短畅通路径，
//      初始化为 -1 ，表示不可达。
//
//      再使用一个队列 q 来记录待访问的单元格。
//
//      最开始只有 (0, 0) 在畅通路径上，所以 dist[0][0] = 0 ，
//      并将 (0, 0) 加入队列 q 中。
//
//      当 q 不为空时，从队列中取出一个单元格 (r, c) ，
//      分别计算其 8 个方向上的相邻单元格 (rr, cc) 。
//
//      如果 (rr, cc) 合法 且 对应单元格为 0 且 未访问过，
//      则将 dist[rr][cc] 更新为 dist[r][c] + 1 ，
//      并将 (rr, cc) 加入队列 q 中。
//
//      最后 dist[n - 1][n - 1] 即为最短畅通路径，
//      如果 (n - 1, n - 1) 不可达，
//      那么 dist[n - 1][n - 1] 为 -1
//
//
//      时间复杂度：O(n ^ 2)
//          1. 需要初始化矩阵 dist 中的全部 O(n ^ 2) 个元素
//          2. 最差情况下，需要遍历全部 O(n ^ 2) 个单元格
//      空间复杂度：O(n ^ 2)
//          1. 需要维护一个队列 q 存储待访问的单元格，
//              最差情况下需要放入全部 O(n ^ 2) 的单元格
//          2. 需要维护一个大小为 O(n ^ 2) 的矩阵 dist ，
//              用于记录左上角到每个单元格的最短路径


use std::collections::VecDeque;


// 8 个方向的位置改变量
static DIRS: [(i32, i32); 8] = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)];


impl Solution {
    pub fn shortest_path_binary_matrix(grid: Vec<Vec<i32>>) -> i32 {
        let n = grid.len();
        // 起止点如果有一个不是 0 ，那么不存在畅通路径，直接返回 -1
        if grid[0][0] != 0 || grid[n - 1][n - 1] != 0 {
            return -1;
        }
        // dist[r][c] 表示从左上角到 (r, c) 的最短畅通路径，
        // 初始化为 -1 ，表示不可达
        let mut dist = vec![vec![-1; n]; n];
        // 最开始只有 (0, 0) 在最短畅通路径中，距离为 1
        dist[0][0] = 1;
        // 初始化一个队列 q ，存储待访问的单元格
        let mut q: VecDeque<(i32, i32)> = VecDeque::new();
        // 最开始只有 (0, 0) 在待访问队列中
        q.push_back((0, 0));
        while !q.is_empty() {
            // 获取队首单元格的下标
            let (r, c) = q.pop_front().unwrap();
            // 遍历 8 个方向的偏移量
            for (dr, dc) in DIRS {
                // 计算相邻单元格的下标
                let rr = r + dr;
                let cc = c + dc;
                // 如果 (rr, cc) 合法 且 对应单元格为 0 且 未访问过
                if 0 <= rr && rr < n as i32 && 
                    0 <= cc && cc < n as i32 && 
                    grid[rr as usize][cc as usize] == 0 && 
                    dist[rr as usize][cc as usize] == -1 {
                        // 更新 dist[rr][cc] 为 dist[r][c] + 1
                        dist[rr as usize][cc as usize] = dist[r as usize][c as usize] + 1;
                        // 将 (rr, cc) 加入队列中
                        q.push_back((rr, cc));
                }
            }
        }

        // dist[n - 1][n - 1] 即为最短畅通路径，
        // 如果 (n - 1, n - 1) 不可达，
        // 那么 dist[n - 1][n - 1] 为 -1
        dist[n - 1][n - 1]
    }
}
