// 链接：https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/
// 题意：给定一个数字字符串，求最少能表示为多少个只含 01 的数字字符串之和？


// 数据限制：
//   1 <= n.length <= 10 ^ 5
//   n 仅含有数字
//   n 不含前导零且表示一个正整数


// 输入： n = "32"
// 输出： 3
// 解释： 10 + 11 + 11 = 32

// 输入： n = "82734"
// 输出： 8
// 解释： 11111 + 11111 + 10111 + 10101 + 
//       10100 + 10100 + 10100 + 10000 = 82734

// 输入： n = "27346209830709182346"
// 输出： 9


// 思路： 贪心
//
//      一个 01 数字字符串只能对每一个十进制位提供最多一个 1 ，
//      所以如果一个十进制位是 x 的话，那么至少需要 x 个 01 数字字符串。
//
//      那么只需要找到所有十进制位的最大值 ans ，即为最少需要的 01 数字字符串个数。
//
//      
//      时间复杂度：O(|n|)
//          1. 需要遍历 n 中全部 O(|n|) 个数字位
//      空间复杂度：O(1)
//          1. 只需用维护常数个额外变量


impl Solution {
    pub fn min_partitions(n: String) -> i32 {
        // 找到最大的数字位并返回
        (n.as_bytes().iter().max().unwrap() - b'0') as i32
    }
}
