// 链接：https://leetcode.com/problems/maximum-erasure-value/
// 题意：给定一个数组 nums ，求其所有不含重复数字的子数组中，数字和的最大值？

// 数据限制：
//  1 <= nums.length <= 10 ^ 5
//  1 <= nums[i] <= 10 ^ 4


// 输入： nums = [4,2,4,5,6]
// 输出： 17
// 解释： 不含重复数字的数字和最大的子数组为 [2,4,5,6]

// 输入： nums = [5,2,1,2,5,2,1,2,5]
// 输出： 8
// 解释： 不含重复数字的数字和最大的子数组为 [5,2,1] 或 [1,2,5]


// 思路： 滑动窗口
//
//      如果一道题目需要在所有满足某种状态的连续子串/连续子数组中，
//      找到满足题意的一个，那么可以考虑滑动窗口。
//
//      本题需要在所有不含重复数字的连续子数组中，找到数字和最大的那个。
//
//      那么我们使用滑动窗口 [l, r] 表示一个不含重复数字的连续子数组，
//      初始化为左边界 l = 0 ，右边界 r = -1 ，表示初始窗口为空。
//
//      同时我们使用一个集合 used_nums 来维护滑动窗口中已经出现过的数字。
//
//      然后不断右移右边界 r ，准备将其纳入到滑动窗口中考虑。
//
//      题目是需要我们找到数字和最大的不含重复字符的连续子串，
//      所以我们贪心地尽可能不缩小滑动窗口，除非 nums[r] 已在滑动窗口中。
//
//      此时，我们需要不断右移左边界 l ，直至 nums[r] 不在滑动窗口中。
//      然后将 nums[r] 真正纳入滑动窗口中，
//      此时的滑动窗口就是以 r 为右边界的不含重复数字且数字和最大的滑动窗口。
//
//      我们统计所有滑动窗口的数字和的最大值到 ans 中，
//      则 ans 就是不含重复数字的连续子数组的数字和的最大值。
//
//
//      设 nums 中不同数字的个数为 C 。
//
//      时间复杂度：O(n)
//          1. 需要遍历 nums 中全部 O(n) 个数字
//      空间复杂度：O(C)
//          1. 需用维护 used_nums 保存全部 O(C) 个不同的数字


use std::collections::HashSet;


impl Solution {
    pub fn maximum_unique_subarray(nums: Vec<i32>) -> i32 {
        // 滑动窗口 [l, r] 内的数字是不重复的，
        // 初始化左边界 l 为 0 ，右边界为 -1 ，滑动窗口内的数字和为 0
        let (mut l, mut total) = (0, 0);
        // 滑动窗口最开始不含已使用的数字，滑动窗口内的数字和的最大值初始化为 0
        let mut used_nums = HashSet::new();
        let mut ans = 0;
        // 不断右移右边界 r ，准备将其纳入到滑动窗口中考虑
        for r in 0..nums.len() {
            // 如果 nums[r] 已在滑动窗口中，
            // 则不断右移左边界，直至 nums[r] 不在滑动窗口中
            while used_nums.contains(&nums[r]) {
                total -= nums[l];
                used_nums.remove(&nums[l]);
                l += 1;
            }
            // 此时 nums[r] 成功进入滑动窗口，标记为已使用，加入 total 中
            used_nums.insert(nums[r]);
            total += nums[r];
            // 更新滑动窗口数字和的最大值
            ans = ans.max(total);
        }

        ans
    }
}
