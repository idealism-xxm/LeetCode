// 链接：https://leetcode.com/problems/longest-substring-without-repeating-characters/
// 题意：给定一个字符串 s ，返回最长不含重复字符的子串的长度。


// 数据限制：
//  0 <= s.length <= 5 * 10 ^ 4
//  s 只含有英文字母、数字、符号和空格


// 输入： s = "abcabcbb"
// 输出： 3
// 解释： 最长不含重复字符的子串是 "abc" ，长度为 3 。

// 输入： s = "bbbbb"
// 输出： 1
// 解释： 最长不含重复字符的子串是 "b" ，长度为 1 。

// 输入： s = "pwwkew"
// 输出： 3
// 解释： 最长不含重复字符的子串是 "wke" ，长度为 3 。


// 思路： 滑动窗口
//
//      如果一道题目需要在所有满足某种状态的连续子串/连续子数组中，
//      找到满足题意的一个，那么可以考虑滑动窗口。
//
//      本题需要在所有不含重复字符的连续子串中，找到最长的那个。
//
//      那么我们使用滑动窗口 [l, r] 表示一个不含重复字符的连续子串，
//      初始化为左边界 l = 0 ，右边界 r = -1 ，表示初始窗口为空。
//
//      同时我们使用一个集合 used_chars 来维护滑动窗口中已经出现过的字符。
//
//      然后不断右移右边界 r ，准备将其纳入到滑动窗口中考虑。
//
//      题目是需要我们找到最长的不含重复字符的连续子串，
//      所以我们贪心地尽可能不缩小滑动窗口，除非 s[r] 已在滑动窗口中。
//
//      此时，我们需要不断右移左边界 l ，直至 s[r] 不在滑动窗口中。
//      然后将 s[r] 真正纳入滑动窗口中，
//      此时的滑动窗口就是以 r 为右边界的最大滑动窗口，大小为 r - l + 1 。
//
//      我们统计所有滑动窗口的大小的最大值到 ans 中，
//      则 ans 就是最长不含重复字符的连续子串的长度。
//
//
//      设字符集大小为 C 。
//
//      时间复杂度：O(n)
//          1. 需要遍历 s 中全部 O(n) 个字符
//      空间复杂度：O(C)
//          1. 只需用一个集合维护全部 O(C) 种字符


use std::collections::HashSet;


impl Solution {
    pub fn length_of_longest_substring(s: String) -> i32 {
        let s = s.as_bytes();
        // 滑动窗口 [l, r] 内的字符是不重复的，
        // 初始化左边界 l 为 0 ，右边界为 -1
        let mut l = 0;
        // 滑动窗口初始大小为 0 ，不含已使用的字符
        let mut ans = 0;
        let mut used_chars = HashSet::new();
        // 不断右移右边界 r ，准备将其纳入到滑动窗口中考虑
        for r in 0..s.len() {
            // 如果 s[r] 已在滑动窗口中，
            // 则不断右移左边界，直至 s[r] 不在滑动窗口中
            while used_chars.contains(&s[r]) {
                used_chars.remove(&s[l]);
                l += 1;
            }
            // 此时 s[r] 成功进入滑动窗口，标记为已使用，更新滑动窗口最大值
            used_chars.insert(s[r]);
            ans = ans.max(r - l + 1);
        }

        ans as i32
    }
}
