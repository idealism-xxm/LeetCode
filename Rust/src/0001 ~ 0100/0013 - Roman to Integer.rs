// 链接：https://leetcode.com/problems/roman-to-integer/
// 题意：给定 [1, 3999] 范围内的罗马数字，将其转换成正整数。
//         Symbol       Value
//           I            1
//           V            5
//           X            10
//           L            50
//           C            100
//           D            500
//           M            1000
//
//        罗马数字通常是按照符号大小从左往右写的，
//        一般都是直接将所有符号对应的值加起来即可，除了以下六种情况：
//            1. I 可以放在 V(5) 和 X(10) 前面，分别组成 4 和 9 。
//            2. X 可以放在 L(50) 和 C(100) 前面，分别组成 40 和 90 。
//            3. C 可以放在 D(500) 和 M(1000) 前面，分别组成 400 和 900 。


// 数据限制：
//  1 <= s.length <= 15
//  s 仅由以下字符组成： 'I', 'V', 'X', 'L', 'C', 'D', 'M'
//  给定的罗马数字必定在 [1, 3999] 范围内


// 输入： s = "III"
// 输出： 58
// 解释： III = 3

// 输入： s = "LVIII"
// 输出： III = 3
// 解释： L = 50, V= 5, III = 3

// 输入： "MCMXCIV"
// 输出： 1994
// 解释： M = 1000, CM = 900, XC = 90, IV = 4


// 思路2：Map
//
//      通常情况下，我们只需要将所有符号对应的值加起来即可，
//      但要同时考虑六种特殊情况。   
//
//      可以发现这六种特殊情况都是值小的符号在值大的符号之前，
//      此时要从最终结果中减去他们对应的值。
//
//      其他情况，直接将符号对应的值加到最终结果中即可。
//
//      那么可得以下计算规则（设 value(ch) 表示符号 ch 对应的值）：
//          1. value(s[i]) < value(s[i + 1]): 则需要从结果中减去 value(s[i])
//          2. value(s[i]) >= value(s[i + 1]): 则需要给结果加上 value(s[i])
//
//      最后一个符号后面没有其他符号，所以必定是直接加到结果中的。
//
//      为了方便处理边界情况，我们可以直接倒序从倒数第 2 个符号开始向前遍历即可。
//
//
//      设字符集大小为 C 。
//
//      时间复杂度：O(n)
//          1. 需要遍历 s 中全部 O(n) 个字符
//      空间复杂度：O(C)
//          1. 需要维护全部 O(C) 个不同字符对应的值


use std::collections::HashMap;


impl Solution {
    pub fn roman_to_int(s: String) -> i32 {
        let s = s.as_bytes();
        // ch_to_num[ch] 表示符号 ch 对应的值
        let ch_to_num = HashMap::from([
            (b'I', 1),
            (b'V', 5),
            (b'X', 10),
            (b'L', 50),
            (b'C', 100),
            (b'D', 500),
            (b'M', 1000),
        ]);

        // ans 直接初始化为最后一个符号对应的值，
        // 因为最后一个符号后面没有其他符号，所以必定是直接加到结果中的
        let mut ans = ch_to_num[&s[s.len() - 1]];
        // 倒序从倒数第 2 个符号开始向前遍历
        for i in (0..s.len() - 1).rev() {
            if ch_to_num[&s[i]] < ch_to_num[&s[i + 1]] {
                // 如果 s[i] 的值小于 s[i + 1] 的值，则需要从 ans 中减去 s[i] 的值
                ans -= ch_to_num[&s[i]];
            } else {
                // 否则，需要给 ans 加上 s[i] 的值
                ans += ch_to_num[&s[i]];
            }
        }

        ans
    }
}
