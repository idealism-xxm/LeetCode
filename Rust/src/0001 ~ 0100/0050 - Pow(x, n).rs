// 链接：https://leetcode.com/problems/powx-n/
// 题意：给定浮点数 x 和整数 n ，求 x ^ n ？


// 数据限制：
//  -100.0 < x < 100.0
//  -(2 ^ 31) <= n <= 2 ^ 31 - 1
//  -(10 ^ 4) <= x ^ n <= 10 ^ 4


// 输入： x = 2.00000, n = 10
// 输出： 1024.00000

// 输入： x = 2.10000, n = 3
// 输出： 9.26100

// 输入： x = 2.00000, n = -2
// 输出： 0.25000
// 解释： 2 ^ (-2) = (1 / 2) ^ 2 = 1/4 = 0.25


// 思路：快速幂
//
//      我们使用一个具体例子 3 ^ 11 来说明快速幂的原理。
//
//      我们把指数用二进制进行表示，那么 3 ^ 11 可以进行如下拆分：
//          3 ^ 11 = 3 ^ (1011)_2
//                 = 3 ^ (1000)_2 * 3 ^ (10)_2 * 3 ^ (1)_2
//                 = 3 ^ 8 * 3 ^ 2 * 3 ^ 1
//
//      我们可以使用 4 次乘法就能按顺序计算出 3 ^ 1, 3 ^ 2, 3 ^ 4, 3 ^ 8 的全部结果，
//      然后就能用 3 次乘法计算出 3 ^ 11 。
//
//      对于任意幂次方 x ^ n ，我们都可以拆成多个 x ^ (1...)_2 的乘积，
//      其中每个 (1...)_2 的二进制位都只有一个 1 。
//
//      这样就能使用乘法在 O(logn) 内按顺序计算出全部的 x ^ (1...)_2 ，
//      然后就能在 O(logn) 内计算出 x ^ n 。
//
//      实际处理时，我们无需提前计算好所有的子项，可以将两个过程合并在一起，
//      这样空间复杂度就能优化为 O(1) 。
//
//
//      时间复杂度： O(logn)
//          1. 只需要循环 O(logn) 次
//      空间复杂度： O(1)
//          1. 只需要使用常数个额外变量


impl Solution {
    pub fn my_pow(mut x: f64, n: i32) -> f64 {
        let mut n = n as i64;
        // 如果 n < 0 ，则需要提前取倒数，并将 n 变成绝对值
        if n < 0 {
            x = 1.0 / x;
            n = -n;
        }

        let mut ans = 1.0;
        // 如果指数还有为 1 的二进制位，则继续处理
        while n > 0 {
            // 如果此时最低位为 1 ，则 x 对 ans 有贡献
            if n & 1 == 1 {
                ans *= x;
            }

            n >>= 1;
            // x 自乘，相当于子项的指数二进制位左移一位
            x *= x;
        }

        ans
    }
}
