// 链接：https://leetcode.com/problems/remove-element/
// 题意：给定一个整数数组 nums 和一个整数 val ，原地移除等于 val 的数字。
//      将这些不等于 val 的 k 个数字放在 nums 的前 k 个位置，并返回 k 。
//
//      进阶：直接修改 nums ，使用空间复杂度为 O(1) 的算法。


// 数据限制：
//  0 <= nums.length <= 100
//  0 <= nums[i] <= 50
//  0 <= val <= 100


// 输入： nums = [3,2,2,3], val = 3
// 输出： 2, nums = [2,2,_,_]
// 解释： 总有 2 个不等于 3 的数字，所以数字前 2 个位置的数分别为 2,2 。
//       后续位置的数字无论是什么都不影响答案的正确性。

// 输入： nums = [0,1,2,2,3,0,4,2], val = 2
// 输出： 5, nums = [0,1,4,0,3,_,_,_]
// 解释： 总有 5 个不重复的数字，所以数字前 5 个位置的数分别为 0,1,4,0,3 。
//       后续位置的数字无论是什么都不影响答案的正确性。


// 思路： 双指针
//
//      本题是 LeetCode 26 的修改版，需要移除的数字变为指定的整数 val ，
//      改变一下判定逻辑就可以直接复用。
//
//
//      我们维护两个指针 l 和 r 。
//
//      l 表示不等于 val 的数字个数，也是下一个可以放入数字的下标，初始化为 0 。
//
//      r 表示下一个待考虑的数字的下标，初始化为 0 。
//
//      不断右移 r ，如果 nums[r] != val ，
//      则 nums[r] 是不等于 val 的，将其放到 l 处，并右移 l 。
//
//
//      时间复杂度： O(n)
//          1. 需要遍历 nums 中全部 O(n) 个数字
//      空间复杂度： O(1)
//          1. 只需要使用常数个额外变量即可


impl Solution {
    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
        // l 表示不等于 val 的数字个数，也是下一个可以放入数字的下标，初始化为 0
        let mut l = 0;
        // 遍历剩余所有的数字
        for r in 0..nums.len() {
            // 如果当前数字不等于 val ，则 nums[r] 不需要移除，放入 l 处
            if nums[r] != val {
                nums[l] = nums[r];
                l += 1;
            }
        }

        l as i32
    }
}
