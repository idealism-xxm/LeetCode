// 链接：https://leetcode.com/problems/sort-the-matrix-diagonally/
// 题意：给你一个 m * n 的整数矩阵 mat ，将同一条 矩阵对角线 上的元素按升序排序，
//      返回排好序的矩阵。
//
//      矩阵对角线 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，
//      沿右下方向一直到矩阵末尾的元素。


// 数据限制：
//  m == mat.length
//  n == mat[i].length
//  1 <= m, n <= 100
//  1 <= mat[i][j] <= 100


// 输入： mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
// 输出： [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
// 解释： 总共有 6 条对角线，相邻的对角线分别用 ·· 和 || 包裹数字。
//       ·3· |3| ·1· |1|      ·1· |1| ·1· |1|
//       |2| ·2· |1| ·2·  →   |1| ·2· |2| ·2·
//       ·1· |1| ·1· |2|      ·1· |2| ·3· |3|
//
//       对角线的元素排序后，变化如下：
//       1      →  1
//       2,1    →  1,2
//       3,2,1  →  1,2,3
//       3,1,2  →  1,2,3
//       1,2    →  1,2
//       1      →  1
//       

// 输入： mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
// 输出： [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]


// 思路： Map + 排序
//
//      同一对角线上的下标 (r, c) 必定满足 r - c 相同，
//      因为下一个数的下标的 r 和 c 都增加 1 ，差值不变。
//
//      所以我们可以用一个名为 diff_to_nums 的 map 收集所有对角线上的数字，
//      然后将每个对角线上的数字按降序排序。
//
//      最后再按顺序遍历 mat 数组的下标 (r, c) ，
//      依次将对应对角线上的数字 pop 出来放入即可。
//
//      因为我们前面将每个对角线上的数字按降序排序，
//      所以这里每次取出的数字都是当前该对角线上剩余的最小数字。
//
//
//      时间复杂度：O(mn)
//          1. 需要遍历全部 O(mn) 个数字
//          2. 需要对全部 O(m + n) 个对角线进行排序，
//              每个对角线最多有 O(min(m, n)) 个数字，排序时间复杂度为 O(log(min(m, n))) ，
//              总时间复杂度为 O((m + n) * log(min(m, n)))
//      空间复杂度：O(mn)
//          1. 需要维护全部 O(mn) 个数字


use std::collections::HashMap;
use std::cmp::Reverse;


impl Solution {
    pub fn diagonal_sort(mut mat: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let (m, n) = (mat.len(), mat[0].len());
        // diff_to_nums[diff] 维护对角线 i - j 上的所有数字
        let mut diff_to_nums = HashMap::<usize, Vec<i32>>::new();
        // 收集每个对角线的数字
        for r in 0..m {
            for c in 0..n {
                diff_to_nums.entry(r - c).or_default().push(mat[r][c]);
            }
        }
        // 对每个对角线上的数字按降序排序，
        // 这样我们后续使用 pop 就能获取该对角线上剩余的最小数字，无需额外维护对应的下标
        for nums in diff_to_nums.values_mut() {
            nums.sort_by_key(|&num| Reverse(num))
        }
        // 将每个对角线上的数字按从小到大放入对应位置
        for r in 0..m {
            for c in 0..n {
                mat[r][c] = diff_to_nums.entry(r - c).or_default().pop().unwrap();
            }
        }

        mat
    }
}
