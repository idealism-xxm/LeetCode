// 链接：https://leetcode.com/problems/remove-palindromic-subsequences/
// 题意：给定一个只含有 'a' 和 'b' 的字符串 s ，每次可以删除其中一个回文子序列，
//      求最少删除多少次可以使得字符串 s 变成空串？


// 数据限制：
//  1 <= s.length <= 1000
//  s[i] 是 'a' 或 'b'


// 输入： s = "ababa"
// 输出： 1
// 解释： "ababa" 本身就是回文串，只需要删除一次

// 输入： s = "abb"
// 输出： 2
// 解释： "abb" -> "bb" -> ""

// 输入： s = "baabb"
// 输出： 2
// 解释： "baabb" -> "b" -> ""


// 思路： 分类讨论 + 双指针
//
//      有一个很关键的点，就是 s 只含有 'a' 和 'b' 两种字母，
//      所以可以分类讨论：
//          1. len(s) == 0: s 本身就是空串，直接返回 0
//          2. s 是回文串: 一次删除操作就可以将 s 变为空串，直接返回 1
//          2. s 不是回文串：则必定同时包含 'a' 和 'b' ，
//              此时可以先删除包含全部 'a' 的回文子序列，
//              再删除包含全部 'b' 的回文子序列，只需要删除两次，返回 2
//
//      判断 s 是否为回文串可以使用双指针从两端开始比较。
//
//
//      时间复杂度：O(n)
//          1. 需要遍历 s 中全部 O(n) 个字母
//      空间复杂度：O(1)
//          1. 只需要使用常数个额外变量


impl Solution {
    pub fn remove_palindrome_sub(s: String) -> i32 {
        // 空串不需要删除
        if s.len() == 0 {
            return 0;
        }

        // 双指针判断是否为回文串
        let s = s.as_bytes();
        let (mut i, mut j) = (0, s.len() - 1);
        while i < j {
            // 如果不是回文串，则必定同时包含 'a' 和 'b' ，
            // 此时可以先删除包含全部 'a' 的回文子序列，
            // 再删除包含全部 'b' 的回文子序列，只需要删除两次
            if s[i] != s[j] {
                return 2;
            }
            i += 1;
            j -= 1;
        }

        // 此时 s 为回文串，可以直接全部删除
        1
    }
}
