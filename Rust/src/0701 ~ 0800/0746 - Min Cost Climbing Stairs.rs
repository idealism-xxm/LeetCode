// 链接：https://leetcode.com/problems/min-cost-climbing-stairs/
// 题意：给定一个长度为 n 的数组 cost ，其中 cost[i] 表示在楼梯第 i 层向上爬的费用，
//      每次可以向爬 1 层或 2 层。
//
//      初始在第 0 层或第 1 层，求爬到顶层所需的最小费用？


// 数据限制：
//  2 <= cost.length <= 1000
//  0 <= cost[i] <= 999


// 输入： cost = [10,15,20]
// 输出： 15
// 解释： 选择初始在第 1 层。
//       花费 15 ，向上爬 2 层到达最顶层。
//       总费用为 15 。

// 输入： cost = [1,100,1,1,1,100,1,1,100,1]
// 输出： 6
// 解释： 选择初始在第 0 层。
//       花费 1 ，向上爬 2 层达到第 2 层。
//       花费 1 ，向上爬 2 层达到第 4 层。
//       花费 1 ，向上爬 2 层达到第 6 层。
//       花费 1 ，向上爬 1 层达到第 7 层。
//       花费 1 ，向上爬 2 层达到第 9 层。
//       花费 1 ，向上爬 1 层达到最顶层。
//       总费用为 6 。


// 思路： DP
//
//      设 dp[i] 表示爬到第 i 层楼梯所需的最小费用。
//
//      初始化： dp[0] = dp[1] = 0 ，可以选择初始在第 0 层或第 1 层，则这两层无需费用
//
//      由于每次可以向上爬 1 层或 2 层，则状态转移自以下两个状态：
//          1. dp[i - 1]: 在第 i - 1 层向上爬 1 层，总费用为 dp[i - 1] + cost[i - 1]
//          2. dp[i - 2]: 在第 i - 2 层向上爬 2 层，总费用为 dp[i - 2] + cost[i - 2]
//
//      状态转移方程为： dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
//
//      DP 常见的三种优化方式见 LeetCode 583 这题的思路，
//      本题可以采用滚动数组的方式进行优化，能将空间复杂度从 O(n) 优化为 O(1) 。
//
//      dp[i] 仅依赖 dp[i - 1] 和 dp[i - 2] ，所以我们可以使用长度为 3 的一维数组 dp ，
//      其中 dp[i % 3] 表示爬到第 i 层楼梯所需的最小费用，上述方程中涉及 dp 的地方均 % 3 即可。
//      
//      
//      时间复杂度：O(n)
//          1. 需要遍历中全部 O(n) 个状态
//      空间复杂度：O(1)
//          1. 只需要维护常数个额外变量即可


impl Solution {
    pub fn min_cost_climbing_stairs(cost: Vec<i32>) -> i32 {
        let n = cost.len();
        // dp[i % 3] 表示爬到第 i 层楼梯所需的最小费用，初始 dp[0] = dp[1] = 0
        let mut dp = vec![0; 3];
        for i in 2..=n {
            // dp[i] 的状态来源有两个，取两者的较小值：
            //  1. dp[i - 1]: 在第 i - 1 层向上爬 1 层，总费用为 dp[i - 1] + cost[i - 1]
            //  2. dp[i - 2]: 在第 i - 2 层向上爬 2 层，总费用为 dp[i - 2] + cost[i - 2]
            dp[i % 3] = std::cmp::min(dp[(i - 1) % 3] + cost[i - 1], dp[(i - 2) % 3] + cost[i - 2]);
        }

        dp[n % 3]
    }
}
