// 链接：https://leetcode.com/problems/find-all-anagrams-in-a-string/
// 题意：给定两个字符串 s 和 p ，找到 s 中所有 p 的异位词子串，
//      返回这些子串的起始下标。
//      异位词：由相同字母重排列形成的字符串（包括相同的字符串）。

// 数据限制：
//  1 <= s.length, p.length <= 3 * 10 ^ 4
//  s 和 p 仅包含小写字母

// 输入：s = "cbaebabacd", p = "abc"
// 输出：[0,6]
// 解释：起始下标等于 0 的子串是 "cba", 它是 "abc" 的异位词。
//      起始下标等于 6 的子串是 "bac", 它是 "abc" 的异位词。

// 输入：s = "abab", p = "ab"
// 输出：[0,1,2]
// 解释：起始下标等于 0 的子串是 "ab", 它是 "ab" 的异位词。
//      起始下标等于 1 的子串是 "ba", 它是 "ab" 的异位词。
//      起始下标等于 2 的子串是 "ab", 它是 "ab" 的异位词。


// 思路：滑动窗口
//
//      先统计 p 中每个字符的出现次数到 ch_to_cnt 中，
//      然后使用滑动窗口遍历字符串 s 统计满足题意的起始下标即可。
//
//      设我们的滑动窗口的左右指针下标为 l 和 r ，初始都为 0 。
//      子串 s[l..=r] 内每个字符出现的次数都小于等于 p 中对应字符出现的次数。
//
//      那么每次加入字符 s[r] 时，都要消耗 s[r] 的次数，
//      即 ch_to_cnt[s[r]] -= 1 。
//      如果此时 ch_to_cnt[s[r]] == -1 ，则说明子串中 s[r] 出现的次数过多，
//      需要不断右移左指针 l ，直至把一个与 s[r] 相同的字符移除子串。
//
//      这样处理后， s[l..=r] 仍满足每个字符出现次数都不会超，
//      那么只要此时子串的长度 r - l + 1 是 p.len() ，
//      就说明 s[l..=r] 是 p 的异位词，把 l 放入到答案数组中即可。
//
//      时间复杂度：O(|s| + |p|)
//      空间复杂度：O(|p|)

impl Solution {
    pub fn find_anagrams(s: String, p: String) -> Vec<i32> {
        // 统计 p 中每个字符出现的次数
        let mut ch_cnt = vec![0; 26];
        p
            // 转成字符切片
            .as_bytes()
            // 转成迭代器
            .iter()
            // 将字符 ch 映射成 [0, 26) 范围内的下标 
            .map(|ch| (ch - b'a') as usize)
            // 该字符出现次数 +1
            .for_each(|ch| ch_cnt[ch] += 1);

        // 先将 s 转成字符切片，方便后续遍历和引用
        let s = s.as_bytes();
        // [l, r] 这个滑动窗口内的字符完全合法
        let mut l = 0;
        // ans 收集所有合法的异位词子串的起始下标
        let mut ans = Vec::<i32>::new();
        // 带下标遍历 s 中的每个字符
        s
            .iter()
            .map(|ch| (ch - b'a') as usize)
            .enumerate()
            .for_each(|(r, ch)| {
                // 将 s[r] 放入到滑动窗口内，即消耗 ch 字符的可使用次数 1 次
                ch_cnt[ch] -= 1;
                // 如果 ch 可使用次数变为 -1 ，
                // 则说明滑动窗口 [l, r] 内的字符 ch 超出可使用次数了，
                // 需要不断右移 l ，直至移除一个 ch 字符
                if ch_cnt[ch] == -1 {
                    loop {
                        // 移除 s[l] ，则其对应的字符可使用次数 +1
                        let ch_l = (s[l] - b'a') as usize;
                        ch_cnt[ch_l] += 1;
                        l += 1;
                        // 如果刚刚移除了与 ch 相同的字符，
                        // 则现在 [l, r] 内的字符出现次数再次合法，
                        // 不再右移 l ，跳出循环
                        if ch_l == ch {
                            break;
                        }
                    }
                }

                // 如果次数滑动窗口的长度 r - l + 1 恰好是 p.len() ，
                // 则说明 s[l..=r] 就是 p 的异位词，
                // 将起始下标放入 ans
                if r - l + 1 == p.len() {
                    ans.push(l as i32);
                }
            });

        ans
    }
}
