// 链接：https://leetcode.com/problems/sort-array-by-parity/
// 题意：给定一个整型数组 nums ，将所有的偶数移动到数组前面，
//      所有的奇数移动到数组后面，最后返回任何一个满足要求的结果数组。


// 数据限制：
//  1 <= nums.length <= 5000
//  0 <= nums[i] <= 5000


// 输入： nums = [3,1,2,4]
// 输出： [2,4,3,1]
// 解释： [4,2,3,1], [2,4,1,3] 和 [4,2,1,3] 都满足题意

// 输入： nums = [0]
// 输出： [0]


// 思路： 双指针
//
//      我们维护左右指针 l 和 r ，分别指向数组的左右两端。
//
//      当左右指针还未相遇时，继续处理。
//
//      左指针 l 不断向右移动，找到下一个奇数的位置，
//      右指针 r 不断向左移动，找到下一个偶数的位置，
//      如果 l 和 r 未相遇，则交换 l 和 r 位置的数字即可。
//
//
//		时间复杂度： O(n)
//          1. 需要遍历全部 O(n) 个数
//		空间复杂度： O(1)
//          1. 只需要维护常数个额外变量


impl Solution {
    pub fn sort_array_by_parity(mut nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len() as i32;
        // 初始化左右指针 l 和 r ，分别为数组最左和最右的下标
        let (mut l, mut r) = (0, n - 1);
        // 当左右指针还未相遇时，继续处理
        while l < r {
            // 找到左侧的第一个奇数
            while l < n && nums[l as usize] & 1 == 0 {
                // 如果当前还有数字 且 当前数字是偶数，
                // 则 l 向右移动一位，继续判断下一个数
                l += 1;
            }
            // 找到右侧的第一个偶数
            while r >= 0 && nums[r as usize] & 1 == 1 {
                // 如果当前还有数字 且 当前数字是奇数，
                // 则 r 向左移动一位，继续判断下一个数
                r -= 1;
            }
            // 如果左右指针还未相遇，则其对应的数字还需要交换
            if l < r {
                nums.swap(l as usize, r as usize);
            }
        }
        
        // 此时 nums 的左侧是偶数，右侧是奇数
        nums
    }
}
