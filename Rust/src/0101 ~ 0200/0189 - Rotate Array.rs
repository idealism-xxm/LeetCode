// 链接：https://leetcode.com/problems/rotate-array/
// 题意：给定一个整型数组，将它原地循环右移 k 次。
//      进阶：
//          1. 用至少 3 种不同的方法完成
//          2. 使用空间复杂度为 O(1) 的原地方法完成

// 数据限制：
//  1 <= nums.length <= 10 ^ 5
//  -(2 ^ 31) <= nums[i] <= 2 ^ 31 - 1
//  0 <= k <= 10 ^ 5

// 输入：nums = [1,2,3,4,5,6,7], k = 3
// 输出：[5,6,7,1,2,3,4]
// 解释：循环右移 1 次： [7,1,2,3,4,5,6]
//      循环右移 2 次： [6,7,1,2,3,4,5]
//      循环右移 3 次： [5,6,7,1,2,3,4]

// 输入：nums = [-1,-100,3,99], k = 2
// 输出：[3,99,-1,-100]
// 解释：循环右移 1 次： [99,-1,-100,3]
//      循环右移 2 次： [3,99,-1,-100]


// 思路1：模拟
//
//		本题的进阶要求是使用 3 种方法，并且存在空间复杂度为 O(1) 的原地方法。
//      那我们就从最直观的模拟法开始，再通过发现隐藏条件优化解法。
//
//      本题最先想到的解法就是按照题意模拟，
//      计算出 nums[i] 循环右移后所在的位置 j = (i + k) % n ，
//      不过由于原数组 nums 中 j 处的数字可能还没被移动，所以不能直接覆盖。
//
//      使用一个 O(n) 的额外数组 arr ，就可以放心赋值 arr[j] = nums[i] ，
//      最后再把额外数组 arr 中的数字拷贝回原数组 nums 即可。
//
//      时间复杂度：O(n)
//      空间复杂度：O(n)

impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        let n = nums.len();
        // 定义一个长度为 n 的额外数组，
        let mut arr = vec![0; n];
        // 遍历 nums 数组，计算出 nums[i] 循环右移 k 次后的位置，
        // 存入到 arr[(i + k) % n] 中
        for i in 0..n {
            arr[(i + k as usize) % n] = nums[i];
        }
        // 把额外数组 arr 中的数字拷贝会原数组 nums
        for i in 0..n {
            nums[i] = arr[i]
        }
    }
}


// 思路2：GCD
//
//		我们可以注意到思路 1 中使用额外数组的原因是：
//          顺序遍历 nums 数组，担心覆盖还没有被移动的数字。
//
//      那我们不按顺序遍历 nums 数组，而是不断移动即将被覆盖的数字，
//      那么就可以不用额外数组了。
//
//      假设我们从 i 开始循环右移，那么接下来要对 (i + k) % n 循环右移……
//      以此类推，直至我们重新回到 i 。
//
//      不过这样有可能只会处理一部分，
//      例如： nums = [-1,-100,3,99], k = 2 时，我们从 0 开始循环右移，
//      那么结束后， nums 将变为 [3,-100,-1,99] 。
//
//      因此我们可能需要继续从 1 开始遍历，那么这层遍历何时停止呢？
//      其实我们只要知道循环右移的数字达到 n 个时就可以停止了。
//
//      证明：假设我们从 i 开始循环右移，最终第一次回到 i 时遍历了 a 圈。
//          这个过程中遍历了 b 个数字，则有 a * n = b * k ，
//          即 a * n 是 n 和 k 的公倍数。
//          由于循环右移在第一次回到 i 时结束，所以 a * n 要尽量小，
//          那么 a * n 是 n 和 k 的最小公倍数，
//          即 a * n = b * k = lcm(n, k) ，
//          即每次遍历的数字数 b = lcm(n, k) / k ，
//          因此总共需要遍历 n / b = n * k / lcm(n, k) = gcd(n, k) 次
//
//      综上：我们对从 i = 0 开始不断循环右移，结束后继续从 i = 1 开始循环右移……
//          直至 i = gcd(n, k) 时结束。
//          每次循环右移遍历的数字为 lcm(n, k) / k ，总共遍历 gcd(n, k) 次。
//
//      时间复杂度：O(n)
//      空间复杂度：O(1)

impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        let n = nums.len();
        // gcd(n, k) 就是最大遍历次数
        let max_loop = Self::gcd(n, k as usize);
        for i in 0..max_loop {
            // 先保存 i 处的数字
            let mut pre_num = nums[i];
            // 从 i + k 开始赋值
            let mut cur = (i + k as usize) % n;
            // 还没回到 i 时就需要一直遍历
            while cur != i {
                // 先保存 cur 处的数字
                let cur_num = nums[cur];
                // 将 pre 处的数字移动到 cur 处
                nums[cur] = pre_num;
                // 下次循环要处理的位置
                cur = (cur + k as usize) % n;
                // 下次循环要移动的数
                pre_num = cur_num;
            }
            // 最后再将这个路径中最后一个数移动到 cur = i 处
            nums[cur] = pre_num;
        }
    }

    // 辗转相除法计算最大公约数
    fn gcd(a: usize, b: usize) -> usize {
        match b {
            0 => a,
            _ => Self::gcd(b, a % b),
        }
    }
}

// 思路3：三次翻转
//
//		可以发现循环右移 k 次后，
//      数组末尾的 k % n 个数字会移动到数组开始，
//      而数组开始的 n - k % n 个数字，则会向右移动 k % n 次。
//
//      如果我们想将数组 nums 整体翻转，
//      则可以使得末尾的 k % n 个数移动至数组开始，
//      不过此时 nums[..k % n] 和 nums[k % n..] 的顺序都是反的，
//      所以还需要分别对 nums[..k % n] 和 nums[k % n..] 再次翻转，
//      这样就能获得循环右移 k 次的结果。
//
//
//		时间复杂度： O(n)
//          1. 需要遍历数组 nums 中的全部 O(n) 个数字
//		空间复杂度： O(1)
//          1. 只需要使用常数个额外变量

impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        // 计算最后有多少数字会被移动到数组开始
        let k = k as usize % nums.len();
        // 数组整体翻转
        nums.reverse();
        // 翻转前 k 个数字
        nums[..k].reverse();
        // 翻转后 n - k 个数字
        nums[k..].reverse();
    }
}
