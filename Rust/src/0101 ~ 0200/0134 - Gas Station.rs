// 链接：https://leetcode.com/problems/gas-station/
// 题意：在一条环形路上有 n 个加油站，给定每个加油站 i 可以加油的数量 gas[i] 和
//		到下一个加油站 i + 1 所需消耗的油的数量 cost[i] ，
//		求油箱无限容量的车从哪个加油站开始可以绕环形路一圈，不存在则返回 -1 ？

// 数据限制：
//  gas.length == n
//  cost.length == n
//  1 <= n <= 10 ^ 5
//  0 <= gas[i], cost[i] <= 10 ^ 4

// 输入： gas = [1,2,3,4,5], cost = [3,4,5,1,2]
// 输出： 3
// 解释： 从加油站 3 开始出发，油箱里油的数量 = 4
//		运行到加油站 4 ，油箱里油的数量 = 4 - 1 + 5 = 8
//		运行到加油站 0 ，油箱里油的数量 = 8 - 2 + 1 = 7
//		运行到加油站 1 ，油箱里油的数量 = 7 - 3 + 2 = 6
//		运行到加油站 2 ，油箱里油的数量 = 6 - 4 + 3 = 5
//		运行到加油站 3 需要花费 5 ，而油箱里刚好的油还有 5 ，可以返回出发点

// 输入： gas  = [2,3,4], cost = [3,4,3]
// 输出： -1


// 思路2：一次遍历
//
//      过了这么久再次接触这题，第一反应还是线段树。一次遍历这样简洁的答案还是比较不太容易思考出来。
//
//      1. 如果 sum(gas) - sum(cost) < 0 ，则说明所有的汽油都不够走完全程，直接返回 -1
//      2. 如果 sum(gas) - sum(cost) >= 0 ，则必定存在一个起点 start 能够走完全程。
//
//         我们可以在一次遍历就找到这个起点 start ，初始为 0 
//          同时再维护 tank 表示从 start 开始时走到当前位置时油箱中的汽油，初始为 0
//
//         假设我们现在遍历到第 i 个加油站，先计算此时油箱中的汽油 tank += gas[i] - cost[i] ，
//          (1) 如果 tank >= 0 ，则汽车能从 start 开到 i + 1 ，继续处理即可
//          (2) 如果 tank < 0 ，则汽车在从 i 开到 i + 1 的途中就会没油，只能选择从 i + 1 开始出发
//
//         这种情况下，最后的 start 就是这个起点，直接返回即可。
//
//          证明如下：
//              首先我们循环中的计算保证了汽车能从 start 开到 gas.len() - 1 处，
//              剩下的就是利用反证法证明汽车在此之后还能开回到 start 。
//              假设汽车不能再开到 k ，那么我们可以将整段路程分为三段： s1, s2, s3
//                  s1 表示从 0 开到 k 能获得的汽油，
//                  s2 表示从 k + 1 开到 start - 1 能获得的汽油，
//                  s3 表示从 start 开到 gas.len() - 1 能获得的汽油。
//              则有： 
//                  ① s1 + s2 + s3 >= 0 ：情况 2 说明 sum(gas) - sum(cost) >= 0
//                  ② s3 + s1 < 0 ：假设的汽车无法从 start 开到 k
//
//              按照我们之前在循环中的计算可知， k + 1 必定成为过一个起点，
//              而且由于后续起点换成了 start ，所以无法从 k + 1 开到 start - 1 ，
//              即 s2 < 0 ，结合 ① 可得 s1 + s3 >= 0 ，
//              这与假设 ② 矛盾，因此不存在这样的 k 使得汽车不能再开到 k
//              
//         
//      时间复杂度： O(n)
//      空间复杂度： O(1)

impl Solution {
    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {
        // 获取经过所有加油站后的相关数据：
        //  total_tank: 能获得的所有汽油 total_tank
        //  start: 汽车最后能从 start 开到终点 gas.len() - 1 处
        //  tank: 从 start 开到终点 gas.len() - 1 处时，油箱中剩余的汽油 tank
        let (total_tank, start, _) = gas
            // 转成迭代器
            .iter()
            // 同时遍历 cost
            .zip(cost.iter())
            // 附上下标
            .enumerate()
            // 使用 fold 开始积累 
            .fold(
                // 初始化 total_tank, start, tank 都是 0
                (0, 0, 0), 
                // 根据上一个位置的积累值，通过本次位置的 gas 和 cost 返回出新的积累值
                |(total_tank, start, tank), (i, (&gas, &cost))| {
                    // 计算到当前这个位置能给油箱中增加的汽油
                    let diff_gas = gas - cost;
                    // 如果到当前位置后，汽油不足，则必定是无法从 i 到达 i + 1 ，
                    // 那么需要让汽车从 i + 1 开始，油箱 tank 清空
                    if tank + diff_gas < 0 {
                        (total_tank + diff_gas, i + 1, 0)
                    } else {
                        // 如果到当前位置后，汽油足够开到 i + 1 ，则维持 start 不变
                        (total_tank + diff_gas, start, tank + diff_gas)
                    }
                },
            );

        // 如果所有的汽油不足以支撑开完全程，则直接返回 -1
        if total_tank < 0 {
            -1
        } else {
            // 如果所有的汽油可以支撑开完全程，则 start 就是一个合法的起点
            start as i32
        }
    }
}
