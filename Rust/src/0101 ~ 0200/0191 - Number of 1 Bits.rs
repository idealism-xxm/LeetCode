// 链接：https://leetcode.com/problems/number-of-1-bits/
// 题意：给定一个无符号整数，返回其二进制位中 1 的个数。
//
//      进阶：如果这个函数需要频繁调用，如何优化它？


// 数据限制：
//  输入是一个长度为 32 的二进制串


// 输入： n = 00000000000000000000000000001011
// 输出： 3
// 解释： 二进制位中总共有 3 个 1

// 输入： n = 00000000000000000000000010000000
// 输出： 1
// 解释： 二进制位中总共有 1 个 1

// 输入： n = 11111111111111111111111111111101
// 输出： 31
// 解释： 二进制位中总共有 31 个 1


// 思路： 位运算
//
//      最容易想到的就是枚举全部 32 位，统计其中 1 的个数。
//
//      但考虑到有进阶优化的要求，所以可以继续思考其他方式。
//
//      可以注意到 n & (n - 1) 会移除 n 二进制位的最后一个 1 ，
//      那么使用这个方法更新 n 并进行统计，
//      就只需要循环 1 的个数次，理论上更优。
//
//      为什么 n & (n - 1) 会移除最后一个 1 呢？
//
//      我们可以看这样一个样例，假设 n 的二进制表示为 xxxx1000 ，
//      只关心最后一个 1 ，之前的位 x 不影响结果。
//
//      那么 n - 1 由于产生了借位就是 xxxx0111 ，
//      可以看到从 n 的最后一个 1 往后的所有位都与 n - 1 对应的位相反，
//      则按位与操作不会影响前面的 x ，并会将后续的所有位清零，
//      从而达到了移除最后一个 1 的目的。
//
//
//      设 C 表示 n 中二进制位中 1 的个数。
//
//      时间复杂度：O(C)
//          1. 需要移除并统计 n 中全部 O(C) 个 1
//      空间复杂度：O(1)
//          1. 只需要维护常数个额外变量即可


impl Solution {
    pub fn hammingWeight (mut n: u32) -> i32 {
        // ans 表示 n 的二进制中 1 的个数
        let mut ans = 0;
        // 当 n > 0 时，表示还有二进制位的 1 ，需要继续处理统计
        while n > 0 {
            // 移除 n 二进制位的最后一个 1
            n &= n - 1;
            // 将当前移除的 1 纳入统计
            ans += 1;
        }

        ans
    }
}
