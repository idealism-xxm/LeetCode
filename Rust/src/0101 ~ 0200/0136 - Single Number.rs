// 链接：https://leetcode.com/problems/single-number/
// 题意：给一个整数数组，有一个数出现一次，其他数均出现两次，找出出现一次的数？


// 数据限制：
//  1 <= nums.length <= 3 * 10 ^ 4
//  -(3 * 10 ^ 4) <= nums[i] <= 3 * 10 ^ 4
//  数组中只有一个数字出现一次，其他数字均出现两次


// 输入：nums = [2,2,1]
// 输出：1

// 输入：nums = [4,1,2,1,2]
// 输出：4

// 输入：nums = [1]
// 输出：1


// 思路： 异或（位运算）
//
//		a ^ a = 0 ，所以出现两次的数异或后会相互抵消。
//
//      那么求所有数的异或和即可，最后剩余的就是只出现一次的数
//
//
//      【进阶】给一个字符串 s ，对 s 中的字符随机重排，
//          然后在随机一个位置加上一个新的字母，从而得到字符串 t ，
//          求 t 中新增的字母？
//
//      这就是 LeetCode 389 这题，第一次做没看题解也没意识到可以用异或处理
//
//		时间复杂度： O(n)
//		空间复杂度： O(1)

impl Solution {
    pub fn single_number(nums: Vec<i32>) -> i32 {
        nums
            // 转成迭代器
            .iter()
            // 使用 fold 积累所有数字的异或和
            .fold(0, |result, num| result ^ num)
    }
}
