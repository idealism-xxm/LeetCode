// 链接：https://leetcode.com/problems/stone-game-iv/
// 题意：给定一堆 n 个石头，两人轮流从这堆石头中移除数量是非零平方数的石头，
//      如果有一个人无法再移除石头，则这个人输了，求先手是否必胜？

// 数据限制：
//  0 <= n < 10 ^ 5

// 输入： n = 1
// 输出： true
// 解释： 先手移除 1 个石头，后手无法再移除石头，先手必胜

// 输入： n = 2
// 输出： false
// 解释： 先手只能一处 1 个石头，
//       后手移除 1 个石头，先手无法再移除石头，先手必败

// 输入： n = 4
// 输出： true
// 解释： 先手移除 4 个石头，后手无法再移除石头，先手必胜


// 思路：DP + 博弈论
//
//      假设当前石头数量是 x ，则有：
//          1. 先手必胜：存在一种先手取法 y ，使得 x - y 是先手必败
//          2. 先手必败：不存在一种先手取法 y ，使得 x - y 是先手必败
//      初始化：石头数量为 0 时，先手必败
//
//      最简单的方法就是记忆化搜索，按照前面的条件判断即可。
//      然后就能想到将记忆化搜索转变为 DP ，
//      设 dp[i] 表示石头数量为 i 时，先手是否必胜。
//          true 表示先手必胜， false 表示先手必败。
//      初始化： dp[0 ~ n] = false ，认为所有状态都是先手必败
//      状态转移：枚举先手移除的石头数 j * j ，其中 j 是正整数，且 j * j <= i ，
//              那么如果发现 dp[i - j * j] 是 false ，
//              则先手移除 j * j 个石头时，先手必胜
//
//      最后直接返回 dp[n] 即可
//
//      由于要遍历 [1, n] 内所有可能的石头数量，时间复杂度为 O(n) ，
//      循环内每次都要枚举所有可能的移除数量，时间复杂度为 O(n ^ 0.5) ，
//      则总的时间复杂度为 O(n ^ 1.5)
//
//      时间复杂度： O(n ^ 1.5)
//      空间复杂度： O(n)

use std::vec;

impl Solution {
    pub fn winner_square_game(n: i32) -> bool {
        // 初始化 dp 数组， dp[i] 表示石头数量为 i 时，先手是否必胜。
        // true 表示先手必胜， false 表示先手必败。
        let mut dp = vec![false; (n + 1) as usize];
        // 枚举 [1, n] 内所有可能的石头数量
        for i in 1..=n as usize {
            // 枚举所有可能的移除数量
            for j  in 1..=((i as f64).sqrt() as usize) {
                // 如果 i - j * j 是先手必败，
                // 则先手选择移除 j * j 个石头时，先手必胜
                if !dp[i - j * j] {
                    // 标记先手必胜
                    dp[i] = true;
                    // 跳出循环，更新 i + 1 时的情况
                    break;
                }
            }
        }

        dp[n as usize]
    }
}
