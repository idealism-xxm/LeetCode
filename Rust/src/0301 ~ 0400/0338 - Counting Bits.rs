// 链接：https://leetcode.com/problems/counting-bits/
// 题意：给定一个数字 n ，返回一个长度为 n + 1 的数组 ans ，
//      其中 ans[i] 表示表示数字 i 的二进制位中 1 的个数。
//
//      要求：时间复杂度为 O(n)


// 数据限制：
//  0 <= n <= 10 ^ 5


// 输入： n = 2
// 输出： [0,1,1]
// 解释：
//      0 --> 0     二进制位中有 0 个 1
//      1 --> 1     二进制位中有 1 个 1
//      2 --> 10    二进制位中有 1 个 1

// 输入： n = 5
// 输出： [0,1,1,2,1,2]
// 解释：
//      0 --> 0     二进制位中有 0 个 1
//      1 --> 1     二进制位中有 1 个 1
//      2 --> 10    二进制位中有 1 个 1
//      3 --> 11    二进制位中有 2 个 1
//      4 --> 100   二进制位中有 1 个 1
//      5 --> 101   二进制位中有 2 个 1


// 思路： DP + 位运算
//
//      我们定义 dp 数组，其中 dp[i] 表示数字 i 的二进制位中 1 的个数。
//
//      初始化： dp[0] = 0
//      状态转移： dp[i] = dp[i >> 1] + (i & 1)
//          我们按顺序遍历 [1, n] 中的每一个数字 i ，
//          此时 dp[1..i] 中的所有结果都已确定。
//
//          i 的结果可以拆分成最低位和其余位的两部分计算：
//               1. 最低位对 dp[i] 的贡献就是 i & 1
//               2. 其余位对 dp[i] 的贡献就是 dp[i >> 1]
//          这两者都已知，所以可以在 O(1) 内完成状态转移
//		
//
//		时间复杂度： O(n)
//          1. 需要遍历计算全部 O(n) 个数的结果
//          2. 对每个数都要进行的状态转移，都可以在 O(1) 内完成
//		空间复杂度： O(n)
//          1. 需要存储最终的 O(n) 个结果


impl Solution {
    pub fn count_bits(n: i32) -> Vec<i32> {
        // dp[i] 表示数字 i 的二进制位中 1 的个数，
        // 初始化 dp[0] = 0 ，其他会在循环中计算
        let mut dp = vec![0; n as usize + 1];
        // 按顺序遍历 [1, n] 中每一个数，进行状态转移
        for i in 1..=n as usize {
            // 此时 dp[0..i] 中的所有结果都已确定。
            //
            // i 的结果可以拆分成最低位和其余位的两部分计算：
            //      1. 最低位对 dp[i] 的贡献就是 i & 1
            //      2. 其余位对 dp[i] 的贡献就是 dp[i >> 1]
            // 这两者都已知，所以可以在 O(1) 内完成状态转移
            dp[i] = dp[i >> 1] + (i as i32 & 1);
        }

        dp
    }
}
