// 链接：https://leetcode.com/problems/burst-balloons/
// 题意：有 n 个气球，每个气球上都有一个数字，
//      用一个长度为 n 的整型数组 nums 表示，
//      射爆第 i 个可以获得 nums[i - 1] * nums[i] * nums[i + 1] 个硬币，
//      （如果 i - 1 或 i + 1 不合法，则认为存在一个数字为 1 的气球）
//      求最大能获得的硬币个数？

// 数据限制：
//  n == nums.length
//  1 <= n <= 500
//  0 <= nums[i] <= 100

// 输入： nums = [3,1,5,8]
// 输出： 167
// 解释： nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
//       coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

// 输入： nums = [1,5]
// 输出： 10
// 解释： nums = [1,5] --> [5] --> []
//       coins = 1*1*5 + 1*5*1 = 10


// 思路：区间 DP
//
//      最开始还没想到 DP ，想了一种贪心的方法，但感觉不是太对，
//      但算了一下时间复杂度， O(n ^ 3) 的 DP 好像有点过不了，就放弃了。
//
//      看了讨论区的标题，发现正解就是 DP ，而且时间复杂度是 O(n ^ 3) ，
//      那很明显就是区间 DP 了。
//
//      设 dp[l][r] 表示射爆 [l, r] 内的所有气球后，能获得的硬币最大值，
//      初始都是 0 。
//      我们枚举左右区间 l 和 r ，然后枚举这个区间内最后射爆的气球 k ，
//      那么最后射爆的气球获得的硬币数 coins_k = nums[l - 1] * nums[k] * nums[r + 1]
//      （注意前一个气球是 l - 1 ，后一个气球是 r + 1 ，因为 [l, r] 内的其他气球已经被射爆了）
//      那么 dp[l][r] = max(dp[l][k - 1] + coins_k + dp[k + 1][r])
//
//
//      时间复杂度： O(n ^ 3)
//      空间复杂度： O(n ^ 2)


impl Solution {
    pub fn max_coins(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        // 使用宏处理获取 nums 的逻辑，后续为了方便处理下标从 1 开始
        // get_num!(i) 返回 nums[i - 1]
        macro_rules! get_num {
            ($i:expr) => (
                // 如果下标不合法，则直接返回 1
                if $i == 0 || $i > n {
                    1
                } else {
                    nums[$i - 1]
                }
            )
        }

        // 初始化 n * n 二维的 dp 数组，长度多 2 ，下标从 1 开始，方便后续处理，
        // dp[l][r] 表示射爆 [l, r] 内的所有气球后，能获得的硬币最大数，
        // 初始都是 0
        let mut dp = vec![vec![0;n + 2];n + 2]; 

        // 枚举区间长度
        for len in 1..=n {
            // 枚举区间右边界，右边界最小为 len ，否则左边界将不合法
            for r in len..=n {
                // 计算区间左边界
                let l = r - len + 1;
                // product 为区间外两边气球数字的乘积，用于计算获得的硬币数
                let product = get_num!(l - 1) * get_num!(r + 1);
                // 枚举 [l, r] 最后射爆的气球
                for k in l..=r {
                    // 1. 射爆气球 k 前，要射爆 [l, k - 1] 和 [k + 1, r] 内的所有气球，
                    //      获得的硬币数为 dp[l][k - 1] + dp[k + 1][r]
                    // 2. 射爆气球 k 后，获得的硬币数为 product * get_num!(k)
                    // 综上：射爆 [l, r] 内的所有气球获得的硬币数为：
                    //      dp[l][k - 1] + dp[k + 1][r] + product * get_num!(k)
                    dp[l][r] = dp[l][r].max(dp[l][k - 1] + product * get_num!(k) + dp[k + 1][r]);
                }
            }
        }

        // 最后返回消掉 [1, n] 内所有气球后的最大硬币数
        dp[1][n]
    }
}
