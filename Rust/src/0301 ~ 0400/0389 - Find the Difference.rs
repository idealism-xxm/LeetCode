// 链接：https://leetcode.com/problems/find-the-difference/
// 题意：给一个字符串 s ，对 s 中的字符随机重排，
//      然后在随机一个位置加上一个新的字母，从而得到字符串 t ，
//      求 t 中新增的字母？


// 数据限制：
//  0 <= s.length <= 1000
//  t.length == s.length + 1
//  s 和 t 只包含小写字母

// 输入：s = "abcd", t = "abcde"
// 输出："e"
// 解释：'e' 是 t 中新增的字母

// 输入：s = "", t = "y"
// 输出："y"
// 解释：'y' 是 t 中新增的字母


// 思路：异或（位运算）
//
//      第一反应其实是使用 map 统计 s 每个字母的次数，
//      再减去 t 中每个字母的次数。
//      这样最后次数不为 0 的字母就是新增的字母。
//
//      由于字母只有 26 个，所以时间复杂度和空间复杂度都是 O(1) ，
//      但常数还是比较大的。
//
//      然后在题解区看到标题可以用异或的方式，突然就明白了，
//      其实还有隐藏条件没有被挖掘出来。
//
//      我们把 s 和 t 中拼接在一起，那么题目就转化成了：
//          给定一个字符串，其中一个字母出现奇数次，其余字母出现偶数次，
//          求这个出现奇数次的字母？
//
//      是不是很熟悉？
//      这就是 LeetCode 136 这道题目。
//
//      完全是考察异或的特性 a ^ a = 0 ，这样最后只有出现奇数次的字母会留下来
//
//      （当然本题也可以使用加减法抵消，获得类似的结果，因为数据范围比较小，
//      不过对于 136 这题就只能使用异或了）
//
//
//      时间复杂度：O(n)
//      空间复杂度：O(1)


impl Solution {
    pub fn find_the_difference(s: String, t: String) -> char {
        s
            // 转成字节切片
            .as_bytes()
            // 转成迭代器
            .iter()
            // 串上 t 的字节迭代器
            .chain(t.as_bytes().iter())
            // 使用 fold 积累 ans ，初始为 0 ，
            // 对每个字符都执行异或操作，
            // 这样最后的值就是出现奇数次的字符
            .fold(0, |ans, ch| ans ^ ch)
            // 转成字符类型
            as char
    }
}
